<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"suntus.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第４章－可靠的请求－回复模型">
<meta property="og:type" content="article">
<meta property="og:title" content="zmq中文指南_4">
<meta property="og:url" content="https://suntus.github.io/2015/01/30/zmq%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97-4/index.html">
<meta property="og:site_name" content="Morning~Sun.">
<meta property="og:description" content="第４章－可靠的请求－回复模型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://suntus.github.io/img/zmq47.png">
<meta property="og:image" content="https://suntus.github.io/img/zmq48.png">
<meta property="og:image" content="https://suntus.github.io/img/zmq49.png">
<meta property="og:image" content="https://suntus.github.io/img/zmq50.png">
<meta property="og:image" content="https://suntus.github.io/img/zmq51.png">
<meta property="og:image" content="https://suntus.github.io/img/zmq52.png">
<meta property="og:image" content="https://suntus.github.io/img/zmq53.png">
<meta property="og:image" content="https://suntus.github.io/img/zmq54.png">
<meta property="og:image" content="https://suntus.github.io/img/zmq55.png">
<meta property="article:published_time" content="2015-01-30T00:24:05.000Z">
<meta property="article:modified_time" content="2020-11-09T14:28:59.610Z">
<meta property="article:author" content="suntus">
<meta property="article:tag" content="tr">
<meta property="article:tag" content="zmq">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://suntus.github.io/img/zmq47.png">

<link rel="canonical" href="https://suntus.github.io/2015/01/30/zmq%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97-4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>zmq中文指南_4 | Morning~Sun.</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-55322469-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-55322469-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Morning~Sun.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://suntus.github.io/2015/01/30/zmq%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="suntus">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Morning~Sun.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          zmq中文指南_4
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2015-01-30 08:24:05" itemprop="dateCreated datePublished" datetime="2015-01-30T08:24:05+08:00">2015-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-09 22:28:59" itemprop="dateModified" datetime="2020-11-09T22:28:59+08:00">2020-11-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="第４章－可靠的请求－回复模型"><a href="#第４章－可靠的请求－回复模型" class="headerlink" title="第４章－可靠的请求－回复模型"></a>第４章－可靠的请求－回复模型</h2><span id="more"></span>


<p>　　第三章高级请求－回复模型讲述了zmq的请求－回复模型在实际工作例子中的高级用法。本章来看看可靠性的普遍问题，并在zmq的核心请求－回复模型的基础之上构建一套可靠的消息传输模型。</p>
<p>　　本章我们会着眼于用户空间的请求回复模型(pattern)，以及帮助设计你自己的zmq架构的可复用模型(model)：</p>
<ul>
<li>*懒海盗(Lazy Pirate)*模型：client侧的可靠的请求－回复</li>
<li>*简单海盗(Simple Pirate)*模型：使用负载均衡的可靠的请求－回复</li>
<li>*偏执海盗(Paranoid Pirate)*模型：使用心跳的可靠的请求－回复</li>
<li>*管家(Majordome)*模型：服务导向的可靠的队列</li>
<li>*泰坦尼克(Titanic)*模型：硬件基础的&#x2F;非连接的可靠的队列</li>
<li>*双子星(Binary Star)*模型：主备份服务器故障转移</li>
<li>*自由者(Freelance)*模型：无中介(broker)的可靠的请求－回复</li>
</ul>
<p><strong>什么是”可靠性”？</strong></p>
<p>　　大多数人说”可靠性”但并不知道它们的意思。我们只能针对故障的处理来定义可靠性。也就是说，如果我们能处理一套良好定义和理解的故障，那我们就可以说系统对这些故障是可靠的。不多也不会少。所以我们来看下在一个分布式的zmq应用中可能出现的失败有那些，下面大致按照发生的可能性递减排序的：</p>
<ul>
<li>应用代码是最坏的罪犯。它能崩溃或者退出，僵死或者停止回应，对输入运行的太慢，内存泄露等等。</li>
<li>系统代码——比如我们用zmq写的broker——也可能跟应用代码因为一样的原因死掉。系统代码<em>应该</em>比应用代码更可靠，但它也是能崩溃或者死掉，特别是储存慢连接的message的时候耗尽内存。</li>
<li>消息队列可能溢出，特别是系统代码试着暴力处理慢client的消息。当一个消息队列溢出，它就开始丢弃消息。所以我们会的到”丢失”的消息。</li>
<li>网络可能失效(比如说，WiFi转换或者超出范围了)。zmq在这种情况下会自动重连，但同时message可能会丢失。</li>
<li>硬件可能失效，跑在那台机上的所有进程都会挂掉。</li>
<li>网络可能因为外界的原因失效，比如说交换机上的一些端口会死掉然后网络上的这些部分就会不可抵达。</li>
<li>整个数据中心可能遭雷击、地震、火灾或者电压过压后者冷却失效。</li>
</ul>
<p>　　让一个软件系统能应对<em>所有</em>这些可能的故障是件异常困难且昂贵的工作，这超出了本书的范围。</p>
<p>　　因为上边列表中前五个情况覆盖了差不多99.9%的现实世界的问题(根据我做的一个高度系统的研究，该研究同时告诉我78%的统计数据是现场编造的，而且在你没证明自己错之前不要相信统计数据)，这就是我们要检查的。如果你在一个很有钱的大公司，想做好后两种情况，请尽快联系我的公司！我家后院还有个大洞等着弄成个游泳池的。</p>
<p><strong>设计可靠性</strong></p>
<p>　　为了把事情弄的简单点儿，我们定义可靠性就是”在代码僵死或崩溃的时候继续保持系统正常工作”，一种系统就快要”死掉”的情形。但我们想保持工作正常这件事要比消息传输复杂的多。我们需要检查每个zmq核心消息模型，看看到底怎在代码要死掉的时候让它正常工作(如果我们可以的话)。</p>
<p>　　一个一个来看：</p>
<ul>
<li>请求－回复：如果server死掉(在处理一个请求的时候)，client能检测出来，因为它拿不到回复了。然后它会在愤怒中放弃，等待，稍后重试，找另一个server，等等。如果client死掉，我们现在把它归到”别人的问题”中去。</li>
<li>发布－订阅：如果clinet死掉(已经拿到了一些数据)，server是不会知道的。发布－订阅模型不会从client向server发送任何信息。但client能用其他通道跟server连接，比如说通过请求－回复模型，去询问”请重发我错过的东西”。如果server死掉，就超出这里讨论的范围了。订阅者也能自己检测到是不是运行的太慢，如果太慢就去做一些处理(比如通知管理员然后退出)。</li>
<li>管道：如果一个worker死掉(在工作时)，ventilator是不会知道的。管道像时间一个只会流向一个方向。但下游收集者能检测到有个任务没完成，就会给ventilator返回个信息说”嘿，重新发送324号任务！”如果是ventilator或者收集者挂掉了，不管上游client开始发发送了什么任务作业，它都会等待超时并且重新发送全部任务。这并不优雅，但系统代码真的不应该经常死掉，我也不会一直考虑这个问题。</li>
</ul>
<p>　　本章我们只关注请求－回复模型，这是可靠消息机制最容易实现的模型。</p>
<p>　　基本的请求－回复模型(REQ client跟一个REP　server做阻塞的发送／接收动作)在处理最常见的故障类型的时候很局限。如果server在处理请求的时候崩溃了，那client就会永远停到那儿。如果网络把请求或者回复信息给弄丢了，client也会永远停在那儿。</p>
<p>　　请求－回复模型仍然比TCP好得多，得益于zmq的自动重连，负载均衡等机制。但这对真实的工作仍然不够好。唯一你能真正相信基本的请求－回复模型的地方就是在同一个进程中的两个线程之间。因为这里不用网络失效或者独立的server进程死掉。</p>
<p>　　但，通过增加点儿额外的工作，这个简陋的模型就会变成真实情景中分布式网络的一个良好基础，然后我们会得到一套可靠的请求－回复(reliable request-reply:RRR)模型，我喜欢称之为<em>海盗</em>模型(我希望你最终会知道这个笑话的～)。</p>
<p>　　以我的经验，大致有三种方法去连接client和server。每种都需要特定的可靠性的措施：</p>
<ul>
<li>多client直接跟一个单独的server连接。使用场景：一个单独的已知server，client需要去跟它通信。我们需要处理的故障类型为：server崩溃和重启，网络断开。</li>
<li>多client连接到一个broker代理，该代理把任务分发给多个worker。使用场景：面向服务的事务处理。我们需要处理的故障类型为：worker崩溃和重启，worker太忙，worker过载，队列崩溃和重启，网络断开。</li>
<li>多client连接到多server，没有使用中间代理。使用场景：分布式服务比如名字检索。我们需要处理的故障类型为：server崩溃或重启，server太忙，server过载，网络断开。</li>
</ul>
<p>　　每种方法都有利有弊，常常需要你综合使用它们。我们会详细说明这三种方法。</p>
<p><strong>client侧可靠性(懒海盗模型　Lazy Pirate Pattern)</strong></p>
<p>　　通过改变一下client，我们就能得到非常简单的可靠的请求－回复模型。我们称它为懒海盗模型。我们不去做一个阻塞的接收，而是：</p>
<ul>
<li>轮询REQ　socket，指在真的有回复到达的时候才读取。</li>
<li>如果回复没在预定时间内到达，就重发请求。</li>
<li>重试几次仍没有回复，就放弃该连接。</li>
</ul>
<p>　　如果你使用REQ socket但是没有遵循严格的发送／接收顺序，就会得到错误(技术上来说，REQ socket实现了一个小型有限状态机来强制发送／请求的ping-pong，因此错误代码被称作”EFSM”)。在海盗模型中如果使用REQ socket就会有点儿恼人，因为我们可能会在收到回复之前发送好几个请求。</p>
<p>　　简单正确的做法是在检测到一个错误后就关掉并重启REQ socket:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//lpclient: Lazy Pirate client in C</span><br><span class="line">//  Lazy Pirate client</span><br><span class="line">//  Use zmq_poll to do a safe request-reply</span><br><span class="line">//  To run, start lpserver and then randomly kill/restart it</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line">#define REQUEST_TIMEOUT     2500    //  msecs, (&gt; 1000!)</span><br><span class="line">#define REQUEST_RETRIES     3       //  Before we abandon</span><br><span class="line">#define SERVER_ENDPOINT     &quot;tcp://localhost:5555&quot;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    printf (&quot;I: connecting to server…\n&quot;);</span><br><span class="line">    void *client = zsocket_new (ctx, ZMQ_REQ);</span><br><span class="line">    assert (client);</span><br><span class="line">    zsocket_connect (client, SERVER_ENDPOINT);</span><br><span class="line"></span><br><span class="line">    int sequence = 0;</span><br><span class="line">    int retries_left = REQUEST_RETRIES;</span><br><span class="line">    while (retries_left &amp;&amp; !zctx_interrupted) &#123;</span><br><span class="line">        //  We send a request, then we work to get a reply</span><br><span class="line">        char request [10];</span><br><span class="line">        sprintf (request, &quot;%d&quot;, ++sequence);</span><br><span class="line">        zstr_send (client, request);</span><br><span class="line"></span><br><span class="line">        int expect_reply = 1;</span><br><span class="line">        while (expect_reply) &#123;</span><br><span class="line">            //  Poll socket for a reply, with timeout</span><br><span class="line">            zmq_pollitem_t items [] = &#123; &#123; client, 0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">            int rc = zmq_poll (items, 1, REQUEST_TIMEOUT * ZMQ_POLL_MSEC);</span><br><span class="line">            if (rc == -1)</span><br><span class="line">                break;          //  Interrupted</span><br><span class="line"></span><br><span class="line">            //  Here we process a server reply and exit our loop if the</span><br><span class="line">            //  reply is valid. If we didn&#x27;t a reply we close the client</span><br><span class="line">            //  socket and resend the request. We try a number of times</span><br><span class="line">            //  before finally abandoning:</span><br><span class="line"></span><br><span class="line">            if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">                //  We got a reply from the server, must match sequence</span><br><span class="line">                char *reply = zstr_recv (client);</span><br><span class="line">                if (!reply)</span><br><span class="line">                    break;      //  Interrupted</span><br><span class="line">                if (atoi (reply) == sequence) &#123;</span><br><span class="line">                    printf (&quot;I: server replied OK (%s)\n&quot;, reply);</span><br><span class="line">                    retries_left = REQUEST_RETRIES;</span><br><span class="line">                    expect_reply = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    printf (&quot;E: malformed reply from server: %s\n&quot;,</span><br><span class="line">                        reply);</span><br><span class="line"></span><br><span class="line">                free (reply);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            if (--retries_left == 0) &#123;</span><br><span class="line">                printf (&quot;E: server seems to be offline, abandoning\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                printf (&quot;W: no response from server, retrying…\n&quot;);</span><br><span class="line">                //  Old socket is confused; close it and open a new one</span><br><span class="line">                zsocket_destroy (ctx, client);</span><br><span class="line">                printf (&quot;I: reconnecting to server…\n&quot;);</span><br><span class="line">                client = zsocket_new (ctx, ZMQ_REQ);</span><br><span class="line">                zsocket_connect (client, SERVER_ENDPOINT);</span><br><span class="line">                //  Send request again, on new socket</span><br><span class="line">                zstr_send (client, request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　匹配的server程序为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// lpserver: Lazy Pirate server in C</span><br><span class="line">//  Lazy Pirate server</span><br><span class="line">//  Binds REQ socket to tcp://*:5555</span><br><span class="line">//  Like hwserver except:</span><br><span class="line">//   - echoes request as-is</span><br><span class="line">//   - randomly runs slowly, or exits to simulate a crash.</span><br><span class="line"></span><br><span class="line">#include &quot;zhelpers.h&quot;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    srandom ((unsigned) time (NULL));</span><br><span class="line"></span><br><span class="line">    void *context = zmq_ctx_new ();</span><br><span class="line">    void *server = zmq_socket (context, ZMQ_REP);</span><br><span class="line">    zmq_bind (server, &quot;tcp://*:5555&quot;);</span><br><span class="line"></span><br><span class="line">    int cycles = 0;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        char *request = s_recv (server);</span><br><span class="line">        cycles++;</span><br><span class="line"></span><br><span class="line">        //  Simulate various problems, after a few cycles</span><br><span class="line">        if (cycles &gt; 3 &amp;&amp; randof (3) == 0) &#123;</span><br><span class="line">            printf (&quot;I: simulating a crash\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (cycles &gt; 3 &amp;&amp; randof (3) == 0) &#123;</span><br><span class="line">            printf (&quot;I: simulating CPU overload\n&quot;);</span><br><span class="line">            sleep (2);</span><br><span class="line">        &#125;</span><br><span class="line">        printf (&quot;I: normal request (%s)\n&quot;, request);</span><br><span class="line">        sleep (1);              //  Do some heavy work</span><br><span class="line">        s_send (server, request);</span><br><span class="line">        free (request);</span><br><span class="line">    &#125;</span><br><span class="line">    zmq_close (server);</span><br><span class="line">    zmq_ctx_destroy (context);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/zmq47.png" alt="f47"></p>
<p>　　要运行该测试，需要在两个终端分别启动client和server。server会在几条message之后随机失效，你可以检查client的回复，下面是server的一个典型输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I: normal request (1)</span><br><span class="line">I: normal request (2)</span><br><span class="line">I: normal request (3)</span><br><span class="line">I: simulating CPU overload</span><br><span class="line">I: normal request (4)</span><br><span class="line">I: simulating a crash</span><br></pre></td></tr></table></figure>
<p>　　这里是client的回复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">I: connecting to server...</span><br><span class="line">I: server replied OK (1)</span><br><span class="line">I: server replied OK (2)</span><br><span class="line">I: server replied OK (3)</span><br><span class="line">W: no response from server, retrying...</span><br><span class="line">I: connecting to server...</span><br><span class="line">W: no response from server, retrying...</span><br><span class="line">I: connecting to server...</span><br><span class="line">E: server seems to be offline, abandoning</span><br></pre></td></tr></table></figure>
<p>　　client把每条message都入队并顺序检查回复：那些没有回复或者回复丢失的，那些回复超过一次的，或者乱序的。多运行几次这个测试，直到你能确信该机制能真正工作。你不需要在一个产品级应用中使用顺序计数，它们只是帮我们确认我们的设计。</p>
<p>　　client使用REQ socket，并且强制性关闭／重启，因为REQ socket强制要求严格的发送／接收循环。你可以用DEALER代替，但这并不是一个良好的设计。首先，这意味着你需要模拟REQ对信封的操作(如果你忘了那是什么，不要紧，这里的好消息是你不用必须去这样做。<em>译注：翻译的表达不出原文的味道，有点儿问题，需复查：if you’ve forgotten what that is, it’s a good sign you don’t want to have to it</em>)。其次，这意味这可能会收到你不希望收到的回复。</p>
<p>　　当我们有一组client连接一个单独的server的时候，只在client处理错误是可行的。它能处理server崩溃的问题，但只是在恢复指的是重启同一个server的情况下。如果这是个永久性的故障，比如说server硬件的断电，这种方法就不行了。因为在server的应用代码不管在哪种架构中都是最大的故障来源，依赖一个单独的server并不是个好主意。</p>
<p>　　因此，利弊如下：</p>
<ul>
<li>利：易于理解和实现。<br>-　利：跟现有的client和server应用代码很容易配合。</li>
<li>利：zmq会自动重连知道它能正常工作。</li>
<li>弊：不会故障转移到备份或者替代server上。</li>
</ul>
<p><strong>基本可靠队列(简单海盗模型Simple Pirate Pattern)</strong></p>
<p>　　第二种方法用一个队列代理扩展了懒海盗模型，好让我们能透明的访问多个server，这里能更准确的称作”worker”。我们从一个最小的能工作的模型——简单海盗模型——开始。</p>
<p>　　在所有这些海盗模型中，worker都是无状态的。如果系统需要共享一些状态，比如说共享数据库，在我们设计消息传输框架的时候是不知道的。有个队列代理意味着worker能随时增减，不需要client知道关于worker的任何情况。如果一个worker挂掉了，另一个就会接替上。这是个简单良好的拓扑结构，只有一个缺点，就是中心队列它自己，它可能是个管理上的问题，且是个单点故障。</p>
<p><img src="/img/zmq48.png" alt="f48"></p>
<p>　　队列代理的基础是第三章中说到的负载均衡中介。我们需要做的关于处理死掉或者阻塞住的worker的工作最少是多少呢？答案是非常少。我们在client已经有了一套重试机制。素有使用负载均衡模型会工作的相当好。这也符合zmq的哲学，我们可以通过在中间插上一个原生的代理把端对端模型扩展成像请求－回复模型那种。</p>
<p>　　我们不需要一个特别的client：还是用懒海盗模型中的。下面是队列的代码，这部分是对负载均衡中介的主要任务是特殊定制的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// spqueue: Simple Pirate queue in C</span><br><span class="line">//  Simple Pirate broker</span><br><span class="line">//  This is identical to load-balancing pattern, with no reliability</span><br><span class="line">//  mechanisms. It depends on the client for recovery. Runs forever.</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line">#define WORKER_READY   &quot;\001&quot;      //  Signals worker is ready</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);</span><br><span class="line">    void *backend = zsocket_new (ctx, ZMQ_ROUTER);</span><br><span class="line">    zsocket_bind (frontend, &quot;tcp://*:5555&quot;);    //  For clients</span><br><span class="line">    zsocket_bind (backend,  &quot;tcp://*:5556&quot;);    //  For workers</span><br><span class="line"></span><br><span class="line">    //  Queue of available workers</span><br><span class="line">    zlist_t *workers = zlist_new ();</span><br><span class="line"></span><br><span class="line">    //  The body of this example is exactly the same as lbbroker2.</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmq_pollitem_t items [] = &#123;</span><br><span class="line">            &#123; backend,  0, ZMQ_POLLIN, 0 &#125;,</span><br><span class="line">            &#123; frontend, 0, ZMQ_POLLIN, 0 &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //  Poll frontend only if we have available workers</span><br><span class="line">        int rc = zmq_poll (items, zlist_size (workers)? 2: 1, -1);</span><br><span class="line">        if (rc == -1)</span><br><span class="line">            break;              //  Interrupted</span><br><span class="line"></span><br><span class="line">        //  Handle worker activity on backend</span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            //  Use worker identity for load-balancing</span><br><span class="line">            zmsg_t *msg = zmsg_recv (backend);</span><br><span class="line">            if (!msg)</span><br><span class="line">                break;          //  Interrupted</span><br><span class="line">            zframe_t *identity = zmsg_unwrap (msg);</span><br><span class="line">            zlist_append (workers, identity);</span><br><span class="line"></span><br><span class="line">            //  Forward message to client if it&#x27;s not a READY</span><br><span class="line">            zframe_t *frame = zmsg_first (msg);</span><br><span class="line">            if (memcmp (zframe_data (frame), WORKER_READY, 1) == 0)</span><br><span class="line">                zmsg_destroy (&amp;msg);</span><br><span class="line">            else</span><br><span class="line">                zmsg_send (&amp;msg, frontend);</span><br><span class="line">        &#125;</span><br><span class="line">        if (items [1].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            //  Get client request, route to first available worker</span><br><span class="line">            zmsg_t *msg = zmsg_recv (frontend);</span><br><span class="line">            if (msg) &#123;</span><br><span class="line">                zmsg_wrap (msg, (zframe_t *) zlist_pop (workers));</span><br><span class="line">                zmsg_send (&amp;msg, backend);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //  When we&#x27;re done, clean up properly</span><br><span class="line">    while (zlist_size (workers)) &#123;</span><br><span class="line">        zframe_t *frame = (zframe_t *) zlist_pop (workers);</span><br><span class="line">        zframe_destroy (&amp;frame);</span><br><span class="line">    &#125;</span><br><span class="line">    zlist_destroy (&amp;workers);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　下面是worker代码，它使用了懒海盗模型的server，并为负载均衡模型做了适配(使用REQ　“ready”信号通知)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// spworker: Simple Pirate worker in C</span><br><span class="line">//  Simple Pirate worker</span><br><span class="line">//  Connects REQ socket to tcp://*:5556</span><br><span class="line">//  Implements worker part of load-balancing</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line">#define WORKER_READY   &quot;\001&quot;      //  Signals worker is ready</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *worker = zsocket_new (ctx, ZMQ_REQ);</span><br><span class="line"></span><br><span class="line">    //  Set random identity to make tracing easier</span><br><span class="line">    srandom ((unsigned) time (NULL));</span><br><span class="line">    char identity [10];</span><br><span class="line">    sprintf (identity, &quot;%04X-%04X&quot;, randof (0x10000), randof (0x10000));</span><br><span class="line">    zmq_setsockopt (worker, ZMQ_IDENTITY, identity, strlen (identity));</span><br><span class="line">    zsocket_connect (worker, &quot;tcp://localhost:5556&quot;);</span><br><span class="line"></span><br><span class="line">    //  Tell broker we&#x27;re ready for work</span><br><span class="line">    printf (&quot;I: (%s) worker ready\n&quot;, identity);</span><br><span class="line">    zframe_t *frame = zframe_new (WORKER_READY, 1);</span><br><span class="line">    zframe_send (&amp;frame, worker, 0);</span><br><span class="line"></span><br><span class="line">    int cycles = 0;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmsg_t *msg = zmsg_recv (worker);</span><br><span class="line">        if (!msg)</span><br><span class="line">            break;              //  Interrupted</span><br><span class="line"></span><br><span class="line">        //  Simulate various problems, after a few cycles</span><br><span class="line">        cycles++;</span><br><span class="line">        if (cycles &gt; 3 &amp;&amp; randof (5) == 0) &#123;</span><br><span class="line">            printf (&quot;I: (%s) simulating a crash\n&quot;, identity);</span><br><span class="line">            zmsg_destroy (&amp;msg);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (cycles &gt; 3 &amp;&amp; randof (5) == 0) &#123;</span><br><span class="line">            printf (&quot;I: (%s) simulating CPU overload\n&quot;, identity);</span><br><span class="line">            sleep (3);</span><br><span class="line">            if (zctx_interrupted)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (&quot;I: (%s) normal reply\n&quot;, identity);</span><br><span class="line">        sleep (1);              //  Do some heavy work</span><br><span class="line">        zmsg_send (&amp;msg, worker);</span><br><span class="line">    &#125;</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　要测试该模型，按任意顺序启动一组worker，一个懒海盗client，和队列。你会看到worker到最后都崩溃掉了，然后clinet就重试然后放弃。队列不会停止，你可以反复重启worker和client，该模型能用于任意数量的client和worker。</p>
<p><strong>健壮的可靠队列(偏执海盗模型 Paranoid Pirate Pattern)</strong></p>
<p><img src="/img/zmq49.png" alt="f49"></p>
<p>　　简单海盗队列模型工作的相当好，特别是因为它只是两个现有模型的组合。但，它仍有一些不足：</p>
<ul>
<li>在面对队列崩溃和重启这个问题上它不具备健壮性。client会恢复，但worker不会。尽管zmq会自动重连worker的socket，但在新启动的线程检测的时候，worker病没有发送准备就绪的信号，所以不存在。要修复这个问题，我们必须建立队列到worker之间心跳机制，以便让wokrer能检测到队列已经掉线。</li>
<li>队列不会检测worker的故障，所以如果一个worker在空闲的时候断掉了，队列在发送请求之前并不会把它移除。client等待并重试，但什么都没有。这不是一个严重的问题，但不没有。要让它能正常工作，我们建立worker到队列的心跳，好让队列能在任何状态下检测到一个掉线的worker。</li>
</ul>
<p>　　我们会在一个可能有点儿迂腐的偏执海盗模型中修复这些问题。</p>
<p>　　先前我们在worker上用了一个REQ socket。对偏执海盗的worker，我们会换成DEALER　socket。这让我们能在任何时候都能发送和接收信息，而不是严格执行REQ强制要求的同步发送／接收。DEALER一点不好的是我们必须自己管理信封(重读第三章去了解这个概念)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">// ppqueue: Paranoid Pirate queue in C</span><br><span class="line">//  Paranoid Pirate queue</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line">#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable</span><br><span class="line">#define HEARTBEAT_INTERVAL  1000    //  msecs</span><br><span class="line"></span><br><span class="line">//  Paranoid Pirate Protocol constants</span><br><span class="line">#define PPP_READY       &quot;\001&quot;      //  Signals worker is ready</span><br><span class="line">#define PPP_HEARTBEAT   &quot;\002&quot;      //  Signals worker heartbeat</span><br><span class="line"></span><br><span class="line">//  Here we define the worker class; a structure and a set of functions that</span><br><span class="line">//  act as constructor, destructor, and methods on worker objects:</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    zframe_t *identity;         //  Identity of worker</span><br><span class="line">    char *id_string;            //  Printable identity</span><br><span class="line">    int64_t expiry;             //  Expires at this time</span><br><span class="line">&#125; worker_t;</span><br><span class="line"></span><br><span class="line">//  Construct new worker</span><br><span class="line">static worker_t *</span><br><span class="line">s_worker_new (zframe_t *identity)</span><br><span class="line">&#123;</span><br><span class="line">    worker_t *self = (worker_t *) zmalloc (sizeof (worker_t));</span><br><span class="line">    self-&gt;identity = identity;</span><br><span class="line">    self-&gt;id_string = zframe_strhex (identity);</span><br><span class="line">    self-&gt;expiry = zclock_time ()</span><br><span class="line">                 + HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Destroy specified worker object, including identity frame.</span><br><span class="line">static void</span><br><span class="line">s_worker_destroy (worker_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        worker_t *self = *self_p;</span><br><span class="line">        zframe_destroy (&amp;self-&gt;identity);</span><br><span class="line">        free (self-&gt;id_string);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The ready method puts a worker to the end of the ready list:</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_worker_ready (worker_t *self, zlist_t *workers)</span><br><span class="line">&#123;</span><br><span class="line">    worker_t *worker = (worker_t *) zlist_first (workers);</span><br><span class="line">    while (worker) &#123;</span><br><span class="line">        if (streq (self-&gt;id_string, worker-&gt;id_string)) &#123;</span><br><span class="line">            zlist_remove (workers, worker);</span><br><span class="line">            s_worker_destroy (&amp;worker);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        worker = (worker_t *) zlist_next (workers);</span><br><span class="line">    &#125;</span><br><span class="line">    zlist_append (workers, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The next method returns the next available worker identity:</span><br><span class="line"></span><br><span class="line">static zframe_t *</span><br><span class="line">s_workers_next (zlist_t *workers)</span><br><span class="line">&#123;</span><br><span class="line">    worker_t *worker = zlist_pop (workers);</span><br><span class="line">    assert (worker);</span><br><span class="line">    zframe_t *frame = worker-&gt;identity;</span><br><span class="line">    worker-&gt;identity = NULL;</span><br><span class="line">    s_worker_destroy (&amp;worker);</span><br><span class="line">    return frame;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The purge method looks for and kills expired workers. We hold workers</span><br><span class="line">//  from oldest to most recent, so we stop at the first alive worker:</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_workers_purge (zlist_t *workers)</span><br><span class="line">&#123;</span><br><span class="line">    worker_t *worker = (worker_t *) zlist_first (workers);</span><br><span class="line">    while (worker) &#123;</span><br><span class="line">        if (zclock_time () &lt; worker-&gt;expiry)</span><br><span class="line">            break;              //  Worker is alive, we&#x27;re done here</span><br><span class="line"></span><br><span class="line">        zlist_remove (workers, worker);</span><br><span class="line">        s_worker_destroy (&amp;worker);</span><br><span class="line">        worker = (worker_t *) zlist_first (workers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The main task is a load-balancer with heartbeating on workers so we</span><br><span class="line">//  can detect crashed or blocked worker tasks:</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);</span><br><span class="line">    void *backend = zsocket_new (ctx, ZMQ_ROUTER);</span><br><span class="line">    zsocket_bind (frontend, &quot;tcp://*:5555&quot;);    //  For clients</span><br><span class="line">    zsocket_bind (backend,  &quot;tcp://*:5556&quot;);    //  For workers</span><br><span class="line"></span><br><span class="line">    //  List of available workers</span><br><span class="line">    zlist_t *workers = zlist_new ();</span><br><span class="line"></span><br><span class="line">    //  Send out heartbeats at regular intervals</span><br><span class="line">    uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmq_pollitem_t items [] = &#123;</span><br><span class="line">            &#123; backend,  0, ZMQ_POLLIN, 0 &#125;,</span><br><span class="line">            &#123; frontend, 0, ZMQ_POLLIN, 0 &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //  Poll frontend only if we have available workers</span><br><span class="line">        int rc = zmq_poll (items, zlist_size (workers)? 2: 1,</span><br><span class="line">            HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);</span><br><span class="line">        if (rc == -1)</span><br><span class="line">            break;              //  Interrupted</span><br><span class="line"></span><br><span class="line">        //  Handle worker activity on backend</span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            //  Use worker identity for load-balancing</span><br><span class="line">            zmsg_t *msg = zmsg_recv (backend);</span><br><span class="line">            if (!msg)</span><br><span class="line">                break;          //  Interrupted</span><br><span class="line"></span><br><span class="line">            //  Any sign of life from worker means it&#x27;s ready</span><br><span class="line">            zframe_t *identity = zmsg_unwrap (msg);</span><br><span class="line">            worker_t *worker = s_worker_new (identity);</span><br><span class="line">            s_worker_ready (worker, workers);</span><br><span class="line"></span><br><span class="line">            //  Validate control message, or return reply to client</span><br><span class="line">            if (zmsg_size (msg) == 1) &#123;</span><br><span class="line">                zframe_t *frame = zmsg_first (msg);</span><br><span class="line">                if (memcmp (zframe_data (frame), PPP_READY, 1)</span><br><span class="line">                &amp;&amp;  memcmp (zframe_data (frame), PPP_HEARTBEAT, 1)) &#123;</span><br><span class="line">                    printf (&quot;E: invalid message from worker&quot;);</span><br><span class="line">                    zmsg_dump (msg);</span><br><span class="line">                &#125;</span><br><span class="line">                zmsg_destroy (&amp;msg);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                zmsg_send (&amp;msg, frontend);</span><br><span class="line">        &#125;</span><br><span class="line">        if (items [1].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            //  Now get next client request, route to next worker</span><br><span class="line">            zmsg_t *msg = zmsg_recv (frontend);</span><br><span class="line">            if (!msg)</span><br><span class="line">                break;          //  Interrupted</span><br><span class="line">            zmsg_push (msg, s_workers_next (workers));</span><br><span class="line">            zmsg_send (&amp;msg, backend);</span><br><span class="line">        &#125;</span><br><span class="line">        //  We handle heartbeating after any socket activity. First, we send</span><br><span class="line">        //  heartbeats to any idle workers if it&#x27;s time. Then, we purge any</span><br><span class="line">        //  dead workers:</span><br><span class="line">        if (zclock_time () &gt;= heartbeat_at) &#123;</span><br><span class="line">            worker_t *worker = (worker_t *) zlist_first (workers);</span><br><span class="line">            while (worker) &#123;</span><br><span class="line">                zframe_send (&amp;worker-&gt;identity, backend,</span><br><span class="line">                             ZFRAME_REUSE + ZFRAME_MORE);</span><br><span class="line">                zframe_t *frame = zframe_new (PPP_HEARTBEAT, 1);</span><br><span class="line">                zframe_send (&amp;frame, backend, 0);</span><br><span class="line">                worker = (worker_t *) zlist_next (workers);</span><br><span class="line">            &#125;</span><br><span class="line">            heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        s_workers_purge (workers);</span><br><span class="line">    &#125;</span><br><span class="line">    //  When we&#x27;re done, clean up properly</span><br><span class="line">    while (zlist_size (workers)) &#123;</span><br><span class="line">        worker_t *worker = (worker_t *) zlist_pop (workers);</span><br><span class="line">        s_worker_destroy (&amp;worker);</span><br><span class="line">    &#125;</span><br><span class="line">    zlist_destroy (&amp;workers);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　该队列用worker的心跳扩展了负载均衡模型。心跳是一种”简单”但很难正确做出来的东西。稍后我会更详细的解释一下。</p>
<p>　　下面是偏执海盗模型的worker：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">// ppworker: Paranoid Pirate worker in C</span><br><span class="line">//  Paranoid Pirate worker</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line">#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable</span><br><span class="line">#define HEARTBEAT_INTERVAL  1000    //  msecs</span><br><span class="line">#define INTERVAL_INIT       1000    //  Initial reconnect</span><br><span class="line">#define INTERVAL_MAX       32000    //  After exponential backoff</span><br><span class="line"></span><br><span class="line">//  Paranoid Pirate Protocol constants</span><br><span class="line">#define PPP_READY       &quot;\001&quot;      //  Signals worker is ready</span><br><span class="line">#define PPP_HEARTBEAT   &quot;\002&quot;      //  Signals worker heartbeat</span><br><span class="line"></span><br><span class="line">//  Helper function that returns a new configured socket</span><br><span class="line">//  connected to the Paranoid Pirate queue</span><br><span class="line"></span><br><span class="line">static void *</span><br><span class="line">s_worker_socket (zctx_t *ctx) &#123;</span><br><span class="line">    void *worker = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    zsocket_connect (worker, &quot;tcp://localhost:5556&quot;);</span><br><span class="line"></span><br><span class="line">    //  Tell queue we&#x27;re ready for work</span><br><span class="line">    printf (&quot;I: worker ready\n&quot;);</span><br><span class="line">    zframe_t *frame = zframe_new (PPP_READY, 1);</span><br><span class="line">    zframe_send (&amp;frame, worker, 0);</span><br><span class="line"></span><br><span class="line">    return worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  We have a single task that implements the worker side of the</span><br><span class="line">//  Paranoid Pirate Protocol (PPP). The interesting parts here are</span><br><span class="line">//  the heartbeating, which lets the worker detect if the queue has</span><br><span class="line">//  died, and vice versa:</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *worker = s_worker_socket (ctx);</span><br><span class="line"></span><br><span class="line">    //  If liveness hits zero, queue is considered disconnected</span><br><span class="line">    size_t liveness = HEARTBEAT_LIVENESS;</span><br><span class="line">    size_t interval = INTERVAL_INIT;</span><br><span class="line"></span><br><span class="line">    //  Send out heartbeats at regular intervals</span><br><span class="line">    uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;</span><br><span class="line"></span><br><span class="line">    srandom ((unsigned) time (NULL));</span><br><span class="line">    int cycles = 0;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmq_pollitem_t items [] = &#123; &#123; worker,  0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">        int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);</span><br><span class="line">        if (rc == -1)</span><br><span class="line">            break;              //  Interrupted</span><br><span class="line"></span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            //  Get message</span><br><span class="line">            //  - 3-part envelope + content -&gt; request</span><br><span class="line">            //  - 1-part HEARTBEAT -&gt; heartbeat</span><br><span class="line">            zmsg_t *msg = zmsg_recv (worker);</span><br><span class="line">            if (!msg)</span><br><span class="line">                break;          //  Interrupted</span><br><span class="line"></span><br><span class="line">            //  To test the robustness of the queue implementation we //</span><br><span class="line">            //  simulate various typical problems, such as the worker</span><br><span class="line">            //  crashing or running very slowly. We do this after a few</span><br><span class="line">            //  cycles so that the architecture can get up and running</span><br><span class="line">            //  first:</span><br><span class="line">            if (zmsg_size (msg) == 3) &#123;</span><br><span class="line">                cycles++;</span><br><span class="line">                if (cycles &gt; 3 &amp;&amp; randof (5) == 0) &#123;</span><br><span class="line">                    printf (&quot;I: simulating a crash\n&quot;);</span><br><span class="line">                    zmsg_destroy (&amp;msg);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                if (cycles &gt; 3 &amp;&amp; randof (5) == 0) &#123;</span><br><span class="line">                    printf (&quot;I: simulating CPU overload\n&quot;);</span><br><span class="line">                    sleep (3);</span><br><span class="line">                    if (zctx_interrupted)</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                printf (&quot;I: normal reply\n&quot;);</span><br><span class="line">                zmsg_send (&amp;msg, worker);</span><br><span class="line">                liveness = HEARTBEAT_LIVENESS;</span><br><span class="line">                sleep (1);              //  Do some heavy work</span><br><span class="line">                if (zctx_interrupted)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            //  When we get a heartbeat message from the queue, it means the</span><br><span class="line">            //  queue was (recently) alive, so we must reset our liveness</span><br><span class="line">            //  indicator:</span><br><span class="line">            if (zmsg_size (msg) == 1) &#123;</span><br><span class="line">                zframe_t *frame = zmsg_first (msg);</span><br><span class="line">                if (memcmp (zframe_data (frame), PPP_HEARTBEAT, 1) == 0)</span><br><span class="line">                    liveness = HEARTBEAT_LIVENESS;</span><br><span class="line">                else &#123;</span><br><span class="line">                    printf (&quot;E: invalid message\n&quot;);</span><br><span class="line">                    zmsg_dump (msg);</span><br><span class="line">                &#125;</span><br><span class="line">                zmsg_destroy (&amp;msg);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                printf (&quot;E: invalid message\n&quot;);</span><br><span class="line">                zmsg_dump (msg);</span><br><span class="line">            &#125;</span><br><span class="line">            interval = INTERVAL_INIT;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        //  If the queue hasn&#x27;t sent us heartbeats in a while, destroy the</span><br><span class="line">        //  socket and reconnect. This is the simplest most brutal way of</span><br><span class="line">        //  discarding any messages we might have sent in the meantime://</span><br><span class="line">        if (--liveness == 0) &#123;</span><br><span class="line">            printf (&quot;W: heartbeat failure, can&#x27;t reach queue\n&quot;);</span><br><span class="line">            printf (&quot;W: reconnecting in %zd msec…\n&quot;, interval);</span><br><span class="line">            zclock_sleep (interval);</span><br><span class="line"></span><br><span class="line">            if (interval &lt; INTERVAL_MAX)</span><br><span class="line">                interval *= 2;</span><br><span class="line">            zsocket_destroy (ctx, worker);</span><br><span class="line">            worker = s_worker_socket (ctx);</span><br><span class="line">            liveness = HEARTBEAT_LIVENESS;</span><br><span class="line">        &#125;</span><br><span class="line">        //  Send heartbeat to queue if it&#x27;s time</span><br><span class="line">        if (zclock_time () &gt; heartbeat_at) &#123;</span><br><span class="line">            heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;</span><br><span class="line">            printf (&quot;I: worker heartbeat\n&quot;);</span><br><span class="line">            zframe_t *frame = zframe_new (PPP_HEARTBEAT, 1);</span><br><span class="line">            zframe_send (&amp;frame, worker, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　对这个例子的一些解释：</p>
<ul>
<li>跟以前一样，代码里包含了故障模拟的部分。这让它(a)很难去调试，并且(b)复用的时候很危险。当你想调试它的时候，先把故障模拟给关掉。</li>
<li>worker使用了跟我们为懒海盗设计的client相似的重连机制，主要有两个不同：(a)它会做指数级回退(back-off)，(b)它会无限重试(而client会在重试几次之后报告一个错误)。</li>
</ul>
<p>　　用以下的脚本试试client,queue和worker：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ppqueue &amp;</span><br><span class="line">for i in 1 2 3 4; do</span><br><span class="line">    ppworker &amp;</span><br><span class="line">    sleep 1</span><br><span class="line">done</span><br><span class="line">lpclient &amp;</span><br></pre></td></tr></table></figure>
<p>　　你应该能看到worker模拟崩溃然后一个接一个断掉，client最终放弃重试。你可以停掉和重启队列，client和worker会自动重连并继续工作。不管你对队列和worker做了什么，client永远不会得到一个乱序的回复：整个链路要不就正常工作，要不就client放弃重连。</p>
<p><strong>心跳</strong></p>
<p>　　心跳解决知道一个对端是否在线的问题。这并不是专门针对zmq的问题。TCP有一个很长的超时时间(大概30min)，这以为着它不可能知道对端是否死掉或者断线。</p>
<p>　　正确实现心跳很不容易。在写偏执海盗例子的时候，我大概花费了５个小时来调试。剩下的请求－回复链大概只用了10分钟。很容易就创造了”故障”，比如说因为心跳没有正确发送，对端就检测到它们断线了。</p>
<p>　　我们在这里看看人们在zmq中使用心跳的三个主要答案。</p>
<p><strong>摆脱掉它</strong></p>
<p>　　最常见的办法就是不去做心跳，期望系统能正常工作。如果不是大多数就是有很多zmq应用这样做。在很多情景中zmq通过隐藏对端鼓励这样做(译注：这句话感觉不是这样的。<em>ZeroMq encourages this by hiding peers in many cases.</em>)。这样做会引起什么问题呢？</p>
<ul>
<li>我们在应用中使用ROUTER socket的时候，它会记录对端，如果对端断开又重连，应用就会有内存泄露(该应用为每个对端保持的资源)，然后变得越来越慢。</li>
<li>当我们用SUB或者DEALER为基础的数据接收socket，就不能分辨出哪些是正常的沉默(没有数据发送)，那些是不正常的沉默(对端掉线或死掉)。如果一个接收者知道对端挂掉，那它就可能会转向一个备份路由了。</li>
<li>如果你在用一个TCP连接，如果沉默了很长时间，那在一些网络中它就会自动挂掉。发送一些东西(技术上来说是”keep-alive”包而不是心跳)，会保持网络存活。</li>
</ul>
<p><strong>单向心跳</strong></p>
<p>　　第二个选择是从一端每隔大约１s向对端发送一个心跳message。当对端在超时时间(比如几秒)内没有收到心跳，它就会认为对端死掉了。听起来很好，是吗？伤感的说并不是。这会在一些情况下正常工作，但在另一些情况下会有很多恼人的边缘状况。</p>
<p>　　对发布－订阅模式来说，这可以工作，这也是唯一能用单向心跳的模型。SUB　socket不能反过来跟PUB socket通信，但PUB socket能向它的订阅者发送”我还在线”的信息。</p>
<p>　　优化一下的话，就是你可以只在没有数据发送的时候发送心跳。更进一步，如果网络活动是个问题的话(比如说移动网络中连接活动会需要电量)，你可以越来越慢的发送心跳。只要接收者能检测到一个故障(心跳活动的突然终止)，就是好的。</p>
<p>　　这种设计会有几个特别的问题：</p>
<ul>
<li>在发送大量数据的时候会不准确，因为心跳包可能跟在数据后被延迟接收。如果心跳被延迟了，你可能得到错误的超时时间，并由于网络阻塞而断开连接。因此，总是把<em>任何</em>进入的数据都当成心跳，不管发送者有没有对心跳做优化。</li>
<li>发布－订阅模型会在没有接收者的时候丢掉message，但PUSH和DEALER socket会把它们放到队列里。所以如果你向一个挂掉的对端发送心跳，然后它又重新连上线，那它就会得到你发送的所有心跳包，这些心跳包会是几千个。噢！</li>
<li>该设计假设心跳的超时时间在整个网络中都是一样的，但这并不精确。一些对端希望很快的心跳以便快速检测故障，还有一些希望宽松的心跳，以便让网络休息休息节省电量。</li>
</ul>
<p><strong>Ping-Pong心跳</strong></p>
<p>　　第三种选择是用一个ping-pong会话。一个节点向对端发送一个ping命令，对端会回复一个pong命令。两个命令都没有任何有效负载。ping和pong并不是相互关联的。因为”client”和”server”的角色在一些网络中任意的，我们通常会随意指定一端发送一个ping然后接收一个pong。然而，动态的client最清楚网络拓扑结构中的超时时间，所以通常都是client去ping　server。</p>
<p>　　这对所有以ROUTER为基础的中介都管用。我们在第二种模型中使用优化手段能让它工作的更好：把所有进入的数据都当成pong，指在没有发送数据的时候发送ping。</p>
<p><strong>偏执海盗的心跳</strong></p>
<p>　　对偏执海盗模型来说，我们选择第二种方法。这可能不是最简单的选择了：如果要在今天设计，我更可能去试试ping-pong的方法。但原则是相似的。心跳信息流在两个方向都是异步的，任何一端都能检测到对端是否”挂掉”并停止通信。</p>
<p>　　在worker中，下面是我们怎么去处理来自队列的心跳的：</p>
<ul>
<li>我们计算一个<em>活跃度</em>，就是在判断队列挂掉之前我们丢失了多少心跳包。它从３开始，每丢失一个心跳包就减１．</li>
<li>我们在<code>zmq_poll</code>循环中每次等１秒，这是我们的心跳间隔。</li>
<li>如果在这段时间内有来自队列的任何信息，我们就把活跃度重置为３．</li>
<li>如果这段时间内没有任何数据，就把活跃度减１．</li>
<li>如果活跃度降为０，就认为队列已死。</li>
<li>如果队列挂掉了，我们就销毁自己的socket，重新创建一个，再重连。</li>
<li>为了避免打开和关闭太多的socket，在重连之前我们先等一个确定的时间间隔：每次都把等待时间翻倍，最多到32秒。</li>
</ul>
<p>　　下面是我们怎么处理<em>到</em>队列的心跳的：</p>
<ul>
<li>在发送下次心跳的时候我们就计数：因为只是跟一个对端(队列)通信，这只是一个单独的变量。</li>
<li>在<code>zmq_poll</code>循环中，不管什么时候过了这个时间点，我们都向队列发送一个心跳。</li>
</ul>
<p>　　下面是worker最重要的心跳部分代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable</span><br><span class="line">#define HEARTBEAT_INTERVAL  1000    //  msecs</span><br><span class="line">#define INTERVAL_INIT       1000    //  Initial reconnect</span><br><span class="line">#define INTERVAL_MAX       32000    //  After exponential backoff</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line">//  If liveness hits zero, queue is considered disconnected</span><br><span class="line">size_t liveness = HEARTBEAT_LIVENESS;</span><br><span class="line">size_t interval = INTERVAL_INIT;</span><br><span class="line"></span><br><span class="line">//  Send out heartbeats at regular intervals</span><br><span class="line">uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">    zmq_pollitem_t items [] = &#123; &#123; worker,  0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">    int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);</span><br><span class="line"></span><br><span class="line">    if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">        //  Receive any message from queue</span><br><span class="line">        liveness = HEARTBEAT_LIVENESS;</span><br><span class="line">        interval = INTERVAL_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    if (--liveness == 0) &#123;</span><br><span class="line">        zclock_sleep (interval);</span><br><span class="line">        if (interval &lt; INTERVAL_MAX)</span><br><span class="line">            interval *= 2;</span><br><span class="line">        zsocket_destroy (ctx, worker);</span><br><span class="line">        …</span><br><span class="line">        liveness = HEARTBEAT_LIVENESS;</span><br><span class="line">    &#125;</span><br><span class="line">    //  Send heartbeat to queue if it&#x27;s time</span><br><span class="line">    if (zclock_time () &gt; heartbeat_at) &#123;</span><br><span class="line">        heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;</span><br><span class="line">        //  Send heartbeat message to queue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　队列做的事情是相同的，但为每个worker额外管理一个超时时间。</p>
<p>　　这里有一些为设计你自己的心跳的小提示：</p>
<ul>
<li>用<code>zmq_poll</code>或者一个reactor作为你的应用的主逻辑的核心。</li>
<li>以在两端建立心跳连接启动系统，模拟故障来测试，<em>然后</em>才建立其余的信息流。在后来才添加心跳是很需要技巧的。</li>
<li>使用简单的追踪手段，比如说打印到控制台，来调试。为了帮助你在两个端点之间跟踪信息流，可以使用输出转储的方法，比如zmsg提供的那样，递增你的信息个数，以便查看是否有丢失。</li>
<li>在一个实际应用中，心跳必须可配置，并且通常都是跟对端协商的结果。一些对端想要积极的心跳，比如说低到10秒一次，其他的对端可能需要高到３０秒。</li>
<li>如果不同的对端有不同的心跳间隔，你的轮询超时时间应该是这些中最低(时间最短)的一个。</li>
<li>在你用来传输信息的那个socket上建立心跳，这样你的心跳也能当成一个<em>keep-alive</em>信息来防止网络连接死掉(一些防火墙对静默的连接并不友好)。</li>
</ul>
<p><strong>契约和协议</strong></p>
<p>　　如果你留意了，就会发现偏执海盗跟简单海盗并不相互协作，因为心跳的缘故。但我们怎么定义”协作”呢？为了保证协作关系，我们需要一种契约，一种让不同团队在不同时间不同地点写的代码能相互配合工作的一致性。我们称之为”协议(protocal)”。</p>
<p>　　没有说明的尝试很有趣，但对真正的应用来说这并不是一个好的基础。(译注：orz…. <em>It’s fun to experiment without specifications, but taht’s not a sensible basis for real applications.</em>)如果我们想用另一种语言写一个worker会怎么样？我们必须读代码来看这东西是怎么工作的吗？如果我们因为某种原因想换种协议呢？甚至是一个简单的协议，如果它是成功的，那就会逐渐发展变得很复杂。</p>
<p>　　缺少协议是一次性应用的一个确定迹象。所以让我们来为该协议写个契约。怎么做呢？</p>
<p>　　在<a target="_blank" rel="noopener" href="http://rfc.zeromq.org/">frc.zeromq.org</a>有个wiki页专门作为公开的zmq协议的一个主页。要创建一个新的说明，如果需要就在该wiki也上注册，然后遵守指导说明。它相当直观，尽管写技术文件并不是每个人的菜。</p>
<p>　　我用了差不多15分钟的时间写了新的<a target="_blank" rel="noopener" href="http://rfc.zeromq.org/spec:6">Pirate Pattern Protocol</a>。它不是一个大的说明，但它确实抓住了一些本质的东西(“你的队列跟PPP不匹配，请修改!”)。</p>
<p>　　要把PPP变成一个真正的协议还需要做些额外的工作：</p>
<ul>
<li>在READY命令中还应该有一个协议版本号，好让我们能区分不同的PPP版本。</li>
<li>就算是现在，READY和HEARTBEAT也不是完全跟请求和回复信息分开的。要让他们区分的明显，我们需要发送一个包含”信息类型”的message。</li>
</ul>
<p><strong>面向服务的可靠队列(管家模型 Majordome Pattern)</strong></p>
<p><img src="/img/zmq50.png" alt="f50"></p>
<p>　　关于进度很好的一件事是在没有律师和委员会参与的情况下它能发展那么快(译注：orz….　The nice thing about progress is how fast it happens when lawyers and committees aren’t involved.)。这个<a target="_blank" rel="noopener" href="http://rfc.zeromq.org/spec:7">一页纸的MDP说明</a>把PPP变得更具体了。这就是我们如何去设计复杂的架构：从写协议开始，<em>然后</em>再去写软件实现它们。</p>
<p>　　管家协议(MDP)用一种有趣的方法扩展并增强了PPP协议：它给client发送的请求增加了一个”服务名”，让worker去注册特定的服务。增加服务名就把我们的偏执海盗队列变成了面向服务的中介。关于MDP的一个比较好的事情是它基于现有的代码，一个简单的原始协议(PPP)和一套解决清晰问题的明确的改进。这就很容易去实现它。</p>
<p>　　要实现管家模型，我们需要为client和worker写一个框架。在能找到一个更简单的API就能正常工作的情况下，要求程序员必须读具体的说明书显然是不明智的。</p>
<p>　　所以我们的第一个协议(MDP本身)定义了分布式框架的各个部分怎么相互通信的，第二个协议定义了应用程序怎么去跟我们要设计的这个框架通信的。</p>
<p>　　管家模型有两部分，一个client端和一个worker端。因为我们要同时写client和worker应用程序，就需要两个API。下面是client的API使用框架，使用了简单的面向对象方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//  Majordomo Protocol client example</span><br><span class="line">//  Uses the mdcli API to hide all MDP aspects</span><br><span class="line"></span><br><span class="line">//  Lets us build this source without creating a library</span><br><span class="line">#include &quot;mdcliapi.c&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line">    mdcli_t *session = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);</span><br><span class="line"></span><br><span class="line">    int count;</span><br><span class="line">    for (count = 0; count &lt; 100000; count++) &#123;</span><br><span class="line">        zmsg_t *request = zmsg_new ();</span><br><span class="line">        zmsg_pushstr (request, &quot;Hello world&quot;);</span><br><span class="line">        zmsg_t *reply = mdcli_send (session, &quot;echo&quot;, &amp;request);</span><br><span class="line">        if (reply)</span><br><span class="line">            zmsg_destroy (&amp;reply);</span><br><span class="line">        else</span><br><span class="line">            break;              //  Interrupt or failure</span><br><span class="line">    &#125;</span><br><span class="line">    printf (&quot;%d requests/replies processed\n&quot;, count);</span><br><span class="line">    mdcli_destroy (&amp;session);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这就是它了，我们启动一个跟中介的会话，发送一条请求message，得到一个回复message，最后关闭连接。下面是worker的API使用框架：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//  Majordomo Protocol worker example</span><br><span class="line">//  Uses the mdwrk API to hide all MDP aspects</span><br><span class="line"></span><br><span class="line">//  Lets us build this source without creating a library</span><br><span class="line">#include &quot;mdwrkapi.c&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line">    mdwrk_t *session = mdwrk_new (</span><br><span class="line">        &quot;tcp://localhost:5555&quot;, &quot;echo&quot;, verbose);</span><br><span class="line"></span><br><span class="line">    zmsg_t *reply = NULL;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmsg_t *request = mdwrk_recv (session, &amp;reply);</span><br><span class="line">        if (request == NULL)</span><br><span class="line">            break;              //  Worker was interrupted</span><br><span class="line">        reply = request;        //  Echo is complex… :-)</span><br><span class="line">    &#125;</span><br><span class="line">    mdwrk_destroy (&amp;session);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　差不多是对称的，但worker的会话有点儿小不同。worker首先会调用<code>recv()</code>，返回一个空的回复，其后它会返回当前的回复，然后得到一个新的请求。</p>
<p>　　client和worker的API用起来相当简单，因为它们都依赖于我们已经设计的偏执海盗模型的代码。下面是client的API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">// mdcliapi: Majordomo client API in C</span><br><span class="line">//  mdcliapi class - Majordomo Protocol Client API</span><br><span class="line">//  Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.</span><br><span class="line"></span><br><span class="line">#include &quot;mdcliapi.h&quot;</span><br><span class="line"></span><br><span class="line">//  Structure of our class</span><br><span class="line">//  We access these properties only via class methods</span><br><span class="line"></span><br><span class="line">struct _mdcli_t &#123;</span><br><span class="line">    zctx_t *ctx;                //  Our context</span><br><span class="line">    char *broker;</span><br><span class="line">    void *client;               //  Socket to broker</span><br><span class="line">    int verbose;                //  Print activity to stdout</span><br><span class="line">    int timeout;                //  Request timeout</span><br><span class="line">    int retries;                //  Request retries</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  Connect or reconnect to broker</span><br><span class="line"></span><br><span class="line">void s_mdcli_connect_to_broker (mdcli_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    if (self-&gt;client)</span><br><span class="line">        zsocket_destroy (self-&gt;ctx, self-&gt;client);</span><br><span class="line">    self-&gt;client = zsocket_new (self-&gt;ctx, ZMQ_REQ);</span><br><span class="line">    zmq_connect (self-&gt;client, self-&gt;broker);</span><br><span class="line">    if (self-&gt;verbose)</span><br><span class="line">        zclock_log (&quot;I: connecting to broker at %s…&quot;, self-&gt;broker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here we have the constructor and destructor for our class:</span><br><span class="line"></span><br><span class="line">//  Constructor</span><br><span class="line"></span><br><span class="line">mdcli_t *</span><br><span class="line">mdcli_new (char *broker, int verbose)</span><br><span class="line">&#123;</span><br><span class="line">    assert (broker);</span><br><span class="line"></span><br><span class="line">    mdcli_t *self = (mdcli_t *) zmalloc (sizeof (mdcli_t));</span><br><span class="line">    self-&gt;ctx = zctx_new ();</span><br><span class="line">    self-&gt;broker = strdup (broker);</span><br><span class="line">    self-&gt;verbose = verbose;</span><br><span class="line">    self-&gt;timeout = 2500;           //  msecs</span><br><span class="line">    self-&gt;retries = 3;              //  Before we abandon</span><br><span class="line"></span><br><span class="line">    s_mdcli_connect_to_broker (self);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Destructor</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">mdcli_destroy (mdcli_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        mdcli_t *self = *self_p;</span><br><span class="line">        zctx_destroy (&amp;self-&gt;ctx);</span><br><span class="line">        free (self-&gt;broker);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  These are the class methods. We can set the request timeout and number</span><br><span class="line">//  of retry attempts before sending requests:</span><br><span class="line"></span><br><span class="line">//  Set request timeout</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">mdcli_set_timeout (mdcli_t *self, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    self-&gt;timeout = timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Set request retries</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">mdcli_set_retries (mdcli_t *self, int retries)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    self-&gt;retries = retries;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here is the send method. It sends a request to the broker and gets</span><br><span class="line">//  a reply even if it has to retry several times. It takes ownership of</span><br><span class="line">//  the request message, and destroys it when sent. It returns the reply</span><br><span class="line">//  message, or NULL if there was no reply after multiple attempts:</span><br><span class="line"></span><br><span class="line">zmsg_t *</span><br><span class="line">mdcli_send (mdcli_t *self, char *service, zmsg_t **request_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    assert (request_p);</span><br><span class="line">    zmsg_t *request = *request_p;</span><br><span class="line"></span><br><span class="line">    //  Prefix request with protocol frames</span><br><span class="line">    //  Frame 1: &quot;MDPCxy&quot; (six bytes, MDP/Client x.y)</span><br><span class="line">    //  Frame 2: Service name (printable string)</span><br><span class="line">    zmsg_pushstr (request, service);</span><br><span class="line">    zmsg_pushstr (request, MDPC_CLIENT);</span><br><span class="line">    if (self-&gt;verbose) &#123;</span><br><span class="line">        zclock_log (&quot;I: send request to &#x27;%s&#x27; service:&quot;, service);</span><br><span class="line">        zmsg_dump (request);</span><br><span class="line">    &#125;</span><br><span class="line">    int retries_left = self-&gt;retries;</span><br><span class="line">    while (retries_left &amp;&amp; !zctx_interrupted) &#123;</span><br><span class="line">        zmsg_t *msg = zmsg_dup (request);</span><br><span class="line">        zmsg_send (&amp;msg, self-&gt;client);</span><br><span class="line"></span><br><span class="line">        zmq_pollitem_t items [] = &#123;</span><br><span class="line">            &#123; self-&gt;client, 0, ZMQ_POLLIN, 0 &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //  On any blocking call, libzmq will return -1 if there was</span><br><span class="line">        //  an error; we could in theory check for different error codes,</span><br><span class="line">        //  but in practice it&#x27;s OK to assume it was EINTR (Ctrl-C):</span><br><span class="line"></span><br><span class="line">        int rc = zmq_poll (items, 1, self-&gt;timeout * ZMQ_POLL_MSEC);</span><br><span class="line">        if (rc == -1)</span><br><span class="line">            break;          //  Interrupted</span><br><span class="line"></span><br><span class="line">        //  If we got a reply, process it</span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            zmsg_t *msg = zmsg_recv (self-&gt;client);</span><br><span class="line">            if (self-&gt;verbose) &#123;</span><br><span class="line">                zclock_log (&quot;I: received reply:&quot;);</span><br><span class="line">                zmsg_dump (msg);</span><br><span class="line">            &#125;</span><br><span class="line">            //  We would handle malformed replies better in real code</span><br><span class="line">            assert (zmsg_size (msg) &gt;= 3);</span><br><span class="line"></span><br><span class="line">            zframe_t *header = zmsg_pop (msg);</span><br><span class="line">            assert (zframe_streq (header, MDPC_CLIENT));</span><br><span class="line">            zframe_destroy (&amp;header);</span><br><span class="line"></span><br><span class="line">            zframe_t *reply_service = zmsg_pop (msg);</span><br><span class="line">            assert (zframe_streq (reply_service, service));</span><br><span class="line">            zframe_destroy (&amp;reply_service);</span><br><span class="line"></span><br><span class="line">            zmsg_destroy (&amp;request);</span><br><span class="line">            return msg;     //  Success</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (--retries_left) &#123;</span><br><span class="line">            if (self-&gt;verbose)</span><br><span class="line">                zclock_log (&quot;W: no reply, reconnecting…&quot;);</span><br><span class="line">            s_mdcli_connect_to_broker (self);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (self-&gt;verbose)</span><br><span class="line">                zclock_log (&quot;W: permanent error, abandoning&quot;);</span><br><span class="line">            break;          //  Give up</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (zctx_interrupted)</span><br><span class="line">        printf (&quot;W: interrupt received, killing client…\n&quot;);</span><br><span class="line">    zmsg_destroy (&amp;request);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">　　让我们在实际运行中看看client的API，下面这个测试程序做100k次请求－回复循环:</span><br><span class="line"></span><br><span class="line">// mdclient: Majordomo client application in C</span><br><span class="line">//  Majordomo Protocol client example</span><br><span class="line">//  Uses the mdcli API to hide all MDP aspects</span><br><span class="line"></span><br><span class="line">//  Lets us build this source without creating a library</span><br><span class="line">#include &quot;mdcliapi.c&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line">    mdcli_t *session = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);</span><br><span class="line"></span><br><span class="line">    int count;</span><br><span class="line">    for (count = 0; count &lt; 100000; count++) &#123;</span><br><span class="line">        zmsg_t *request = zmsg_new ();</span><br><span class="line">        zmsg_pushstr (request, &quot;Hello world&quot;);</span><br><span class="line">        zmsg_t *reply = mdcli_send (session, &quot;echo&quot;, &amp;request);</span><br><span class="line">        if (reply)</span><br><span class="line">            zmsg_destroy (&amp;reply);</span><br><span class="line">        else</span><br><span class="line">            break;              //  Interrupt or failure</span><br><span class="line">    &#125;</span><br><span class="line">    printf (&quot;%d requests/replies processed\n&quot;, count);</span><br><span class="line">    mdcli_destroy (&amp;session);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　下面是worker的API:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">// mdwrkapi: Majordomo worker API in C</span><br><span class="line">//  mdwrkapi class - Majordomo Protocol Worker API</span><br><span class="line">//  Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.</span><br><span class="line"></span><br><span class="line">#include &quot;mdwrkapi.h&quot;</span><br><span class="line"></span><br><span class="line">//  Reliability parameters</span><br><span class="line">#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable</span><br><span class="line"></span><br><span class="line">//  This is the structure of a worker API instance. We use a pseudo-OO</span><br><span class="line">//  approach in a lot of the C examples, as well as the CZMQ binding:</span><br><span class="line"></span><br><span class="line">//  Structure of our class</span><br><span class="line">//  We access these properties only via class methods</span><br><span class="line"></span><br><span class="line">struct _mdwrk_t &#123;</span><br><span class="line">    zctx_t *ctx;                //  Our context</span><br><span class="line">    char *broker;</span><br><span class="line">    char *service;</span><br><span class="line">    void *worker;               //  Socket to broker</span><br><span class="line">    int verbose;                //  Print activity to stdout</span><br><span class="line"></span><br><span class="line">    //  Heartbeat management</span><br><span class="line">    uint64_t heartbeat_at;      //  When to send HEARTBEAT</span><br><span class="line">    size_t liveness;            //  How many attempts left</span><br><span class="line">    int heartbeat;              //  Heartbeat delay, msecs</span><br><span class="line">    int reconnect;              //  Reconnect delay, msecs</span><br><span class="line"></span><br><span class="line">    int expect_reply;           //  Zero only at start</span><br><span class="line">    zframe_t *reply_to;         //  Return identity, if any</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  We have two utility functions; to send a message to the broker and</span><br><span class="line">//  to (re)connect to the broker:</span><br><span class="line"></span><br><span class="line">//  Send message to broker</span><br><span class="line">//  If no msg is provided, creates one internally</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_mdwrk_send_to_broker (mdwrk_t *self, char *command, char *option,</span><br><span class="line">                        zmsg_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">    msg = msg? zmsg_dup (msg): zmsg_new ();</span><br><span class="line"></span><br><span class="line">    //  Stack protocol envelope to start of message</span><br><span class="line">    if (option)</span><br><span class="line">        zmsg_pushstr (msg, option);</span><br><span class="line">    zmsg_pushstr (msg, command);</span><br><span class="line">    zmsg_pushstr (msg, MDPW_WORKER);</span><br><span class="line">    zmsg_pushstr (msg, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    if (self-&gt;verbose) &#123;</span><br><span class="line">        zclock_log (&quot;I: sending %s to broker&quot;,</span><br><span class="line">            mdps_commands [(int) *command]);</span><br><span class="line">        zmsg_dump (msg);</span><br><span class="line">    &#125;</span><br><span class="line">    zmsg_send (&amp;msg, self-&gt;worker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Connect or reconnect to broker</span><br><span class="line"></span><br><span class="line">void s_mdwrk_connect_to_broker (mdwrk_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    if (self-&gt;worker)</span><br><span class="line">        zsocket_destroy (self-&gt;ctx, self-&gt;worker);</span><br><span class="line">    self-&gt;worker = zsocket_new (self-&gt;ctx, ZMQ_DEALER);</span><br><span class="line">    zmq_connect (self-&gt;worker, self-&gt;broker);</span><br><span class="line">    if (self-&gt;verbose)</span><br><span class="line">        zclock_log (&quot;I: connecting to broker at %s…&quot;, self-&gt;broker);</span><br><span class="line"></span><br><span class="line">    //  Register service with broker</span><br><span class="line">    s_mdwrk_send_to_broker (self, MDPW_READY, self-&gt;service, NULL);</span><br><span class="line"></span><br><span class="line">    //  If liveness hits zero, queue is considered disconnected</span><br><span class="line">    self-&gt;liveness = HEARTBEAT_LIVENESS;</span><br><span class="line">    self-&gt;heartbeat_at = zclock_time () + self-&gt;heartbeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here we have the constructor and destructor for our mdwrk class:</span><br><span class="line"></span><br><span class="line">//  Constructor</span><br><span class="line"></span><br><span class="line">mdwrk_t *</span><br><span class="line">mdwrk_new (char *broker,char *service, int verbose)</span><br><span class="line">&#123;</span><br><span class="line">    assert (broker);</span><br><span class="line">    assert (service);</span><br><span class="line"></span><br><span class="line">    mdwrk_t *self = (mdwrk_t *) zmalloc (sizeof (mdwrk_t));</span><br><span class="line">    self-&gt;ctx = zctx_new ();</span><br><span class="line">    self-&gt;broker = strdup (broker);</span><br><span class="line">    self-&gt;service = strdup (service);</span><br><span class="line">    self-&gt;verbose = verbose;</span><br><span class="line">    self-&gt;heartbeat = 2500;     //  msecs</span><br><span class="line">    self-&gt;reconnect = 2500;     //  msecs</span><br><span class="line"></span><br><span class="line">    s_mdwrk_connect_to_broker (self);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Destructor</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">mdwrk_destroy (mdwrk_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        mdwrk_t *self = *self_p;</span><br><span class="line">        zctx_destroy (&amp;self-&gt;ctx);</span><br><span class="line">        free (self-&gt;broker);</span><br><span class="line">        free (self-&gt;service);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  We provide two methods to configure the worker API. You can set the</span><br><span class="line">//  heartbeat interval and retries to match the expected network performance.</span><br><span class="line"></span><br><span class="line">//  Set heartbeat delay</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">mdwrk_set_heartbeat (mdwrk_t *self, int heartbeat)</span><br><span class="line">&#123;</span><br><span class="line">    self-&gt;heartbeat = heartbeat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Set reconnect delay</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">mdwrk_set_reconnect (mdwrk_t *self, int reconnect)</span><br><span class="line">&#123;</span><br><span class="line">    self-&gt;reconnect = reconnect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This is the recv method; it&#x27;s a little misnamed because it first sends</span><br><span class="line">//  any reply and then waits for a new request. If you have a better name</span><br><span class="line">//  for this, let me know.</span><br><span class="line"></span><br><span class="line">//  Send reply, if any, to broker and wait for next request.</span><br><span class="line"></span><br><span class="line">zmsg_t *</span><br><span class="line">mdwrk_recv (mdwrk_t *self, zmsg_t **reply_p)</span><br><span class="line">&#123;</span><br><span class="line">    //  Format and send the reply if we were provided one</span><br><span class="line">    assert (reply_p);</span><br><span class="line">    zmsg_t *reply = *reply_p;</span><br><span class="line">    assert (reply || !self-&gt;expect_reply);</span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        assert (self-&gt;reply_to);</span><br><span class="line">        zmsg_wrap (reply, self-&gt;reply_to);</span><br><span class="line">        s_mdwrk_send_to_broker (self, MDPW_REPLY, NULL, reply);</span><br><span class="line">        zmsg_destroy (reply_p);</span><br><span class="line">    &#125;</span><br><span class="line">    self-&gt;expect_reply = 1;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmq_pollitem_t items [] = &#123;</span><br><span class="line">            &#123; self-&gt;worker,  0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">        int rc = zmq_poll (items, 1, self-&gt;heartbeat * ZMQ_POLL_MSEC);</span><br><span class="line">        if (rc == -1)</span><br><span class="line">            break;              //  Interrupted</span><br><span class="line"></span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            zmsg_t *msg = zmsg_recv (self-&gt;worker);</span><br><span class="line">            if (!msg)</span><br><span class="line">                break;          //  Interrupted</span><br><span class="line">            if (self-&gt;verbose) &#123;</span><br><span class="line">                zclock_log (&quot;I: received message from broker:&quot;);</span><br><span class="line">                zmsg_dump (msg);</span><br><span class="line">            &#125;</span><br><span class="line">            self-&gt;liveness = HEARTBEAT_LIVENESS;</span><br><span class="line"></span><br><span class="line">            //  Don&#x27;t try to handle errors, just assert noisily</span><br><span class="line">            assert (zmsg_size (msg) &gt;= 3);</span><br><span class="line"></span><br><span class="line">            zframe_t *empty = zmsg_pop (msg);</span><br><span class="line">            assert (zframe_streq (empty, &quot;&quot;));</span><br><span class="line">            zframe_destroy (&amp;empty);</span><br><span class="line"></span><br><span class="line">            zframe_t *header = zmsg_pop (msg);</span><br><span class="line">            assert (zframe_streq (header, MDPW_WORKER));</span><br><span class="line">            zframe_destroy (&amp;header);</span><br><span class="line"></span><br><span class="line">            zframe_t *command = zmsg_pop (msg);</span><br><span class="line">            if (zframe_streq (command, MDPW_REQUEST)) &#123;</span><br><span class="line">                //  We should pop and save as many addresses as there are</span><br><span class="line">                //  up to a null part, but for now, just save one…</span><br><span class="line">                self-&gt;reply_to = zmsg_unwrap (msg);</span><br><span class="line">                zframe_destroy (&amp;command);</span><br><span class="line">                //  Here is where we actually have a message to process; we</span><br><span class="line">                //  return it to the caller application:</span><br><span class="line"></span><br><span class="line">                return msg;     //  We have a request to process</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            if (zframe_streq (command, MDPW_HEARTBEAT))</span><br><span class="line">                ;               //  Do nothing for heartbeats</span><br><span class="line">            else</span><br><span class="line">            if (zframe_streq (command, MDPW_DISCONNECT))</span><br><span class="line">                s_mdwrk_connect_to_broker (self);</span><br><span class="line">            else &#123;</span><br><span class="line">                zclock_log (&quot;E: invalid input message&quot;);</span><br><span class="line">                zmsg_dump (msg);</span><br><span class="line">            &#125;</span><br><span class="line">            zframe_destroy (&amp;command);</span><br><span class="line">            zmsg_destroy (&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (--self-&gt;liveness == 0) &#123;</span><br><span class="line">            if (self-&gt;verbose)</span><br><span class="line">                zclock_log (&quot;W: disconnected from broker - retrying…&quot;);</span><br><span class="line">            zclock_sleep (self-&gt;reconnect);</span><br><span class="line">            s_mdwrk_connect_to_broker (self);</span><br><span class="line">        &#125;</span><br><span class="line">        //  Send HEARTBEAT if it&#x27;s time</span><br><span class="line">        if (zclock_time () &gt; self-&gt;heartbeat_at) &#123;</span><br><span class="line">            s_mdwrk_send_to_broker (self, MDPW_HEARTBEAT, NULL, NULL);</span><br><span class="line">            self-&gt;heartbeat_at = zclock_time () + self-&gt;heartbeat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (zctx_interrupted)</span><br><span class="line">        printf (&quot;W: interrupt received, killing worker…\n&quot;);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在实际运行中看看worker的API，下面这个测试例子是实现一个echo服务:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//  mdworker: Majordomo worker application in C</span><br><span class="line">//  Majordomo Protocol worker example</span><br><span class="line">//  Uses the mdwrk API to hide all MDP aspects</span><br><span class="line"></span><br><span class="line">//  Lets us build this source without creating a library</span><br><span class="line">#include &quot;mdwrkapi.c&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line">    mdwrk_t *session = mdwrk_new (</span><br><span class="line">        &quot;tcp://localhost:5555&quot;, &quot;echo&quot;, verbose);</span><br><span class="line"></span><br><span class="line">    zmsg_t *reply = NULL;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmsg_t *request = mdwrk_recv (session, &amp;reply);</span><br><span class="line">        if (request == NULL)</span><br><span class="line">            break;              //  Worker was interrupted</span><br><span class="line">        reply = request;        //  Echo is complex… :-)</span><br><span class="line">    &#125;</span><br><span class="line">    mdwrk_destroy (&amp;session);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这里有一些对worker API代码的说明：</p>
<ul>
<li>这些API是单线程的。也就是说，worker不会在后台发送心跳。让人高兴的是，这正是我们想要的：如果worker应用被卡住，心跳就会停止，然后中介就会停止向worker继续发送请求。</li>
<li>worker的API不会做指数级的延迟，没必要增加额外的复杂度了。</li>
<li>API不会做任何的错误报告，如果有些东西没有按预期的进行，它们就会引起一个断言(或者依赖语言的异常)。这对引用实现来说很理想，任何协议的错误都会立马显现。对真正的应用来说，API应该对无效的信息有处理措施。</li>
</ul>
<p>　　你可能会想知道在zmq会在对端掉线又上线的能自动重连的情况下，为什么worker API还需要手动关闭它的socket然后启动一个新的。要理解需要回头看看简单海盗和偏执海盗的worker。尽管zmq会自动重连，但这对worker重新注册到broker这件事并不够。我知道至少有两个办法。最简单的也就是我们在这里用的这个，是让worker用心跳去监控连接，如果它判断中介挂掉了，就关闭并重启一个新的socket。另一种是让broker对那些没注册的worker重新注册。这需要协议的支持。</p>
<p>　　现在让我们来设计管家的中介。他的核心结构是一套队列，每个服务一个队列。我们可以创建这些队列来作为worker上线(可以删除它们来作为worker下线，但别忘记现在这么做只是为了简单)。另外，我们为每个服务都维持一个队列。</p>
<p>　　下面是中介：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br></pre></td><td class="code"><pre><span class="line">//  mdbroker: Majordomo broker in C</span><br><span class="line">//  Majordomo Protocol broker</span><br><span class="line">//  A minimal C implementation of the Majordomo Protocol as defined in</span><br><span class="line">//  http://rfc.zeromq.org/spec:7 and http://rfc.zeromq.org/spec:8.</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line">#include &quot;mdp.h&quot;</span><br><span class="line"></span><br><span class="line">//  We&#x27;d normally pull these from config data</span><br><span class="line"></span><br><span class="line">#define HEARTBEAT_LIVENESS  3       //  3-5 is reasonable</span><br><span class="line">#define HEARTBEAT_INTERVAL  2500    //  msecs</span><br><span class="line">#define HEARTBEAT_EXPIRY    HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS</span><br><span class="line"></span><br><span class="line">//  The broker class defines a single broker instance:</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    zctx_t *ctx;                //  Our context</span><br><span class="line">    void *socket;               //  Socket for clients &amp; workers</span><br><span class="line">    int verbose;                //  Print activity to stdout</span><br><span class="line">    char *endpoint;             //  Broker binds to this endpoint</span><br><span class="line">    zhash_t *services;          //  Hash of known services</span><br><span class="line">    zhash_t *workers;           //  Hash of known workers</span><br><span class="line">    zlist_t *waiting;           //  List of waiting workers</span><br><span class="line">    uint64_t heartbeat_at;      //  When to send HEARTBEAT</span><br><span class="line">&#125; broker_t;</span><br><span class="line"></span><br><span class="line">static broker_t *</span><br><span class="line">    s_broker_new (int verbose);</span><br><span class="line">static void</span><br><span class="line">    s_broker_destroy (broker_t **self_p);</span><br><span class="line">static void</span><br><span class="line">    s_broker_bind (broker_t *self, char *endpoint);</span><br><span class="line">static void</span><br><span class="line">    s_broker_worker_msg (broker_t *self, zframe_t *sender, zmsg_t *msg);</span><br><span class="line">static void</span><br><span class="line">    s_broker_client_msg (broker_t *self, zframe_t *sender, zmsg_t *msg);</span><br><span class="line">static void</span><br><span class="line">    s_broker_purge (broker_t *self);</span><br><span class="line"></span><br><span class="line">//  The service class defines a single service instance:</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    broker_t *broker;           //  Broker instance</span><br><span class="line">    char *name;                 //  Service name</span><br><span class="line">    zlist_t *requests;          //  List of client requests</span><br><span class="line">    zlist_t *waiting;           //  List of waiting workers</span><br><span class="line">    size_t workers;             //  How many workers we have</span><br><span class="line">&#125; service_t;</span><br><span class="line"></span><br><span class="line">static service_t *</span><br><span class="line">    s_service_require (broker_t *self, zframe_t *service_frame);</span><br><span class="line">static void</span><br><span class="line">    s_service_destroy (void *argument);</span><br><span class="line">static void</span><br><span class="line">    s_service_dispatch (service_t *service, zmsg_t *msg);</span><br><span class="line"></span><br><span class="line">//  The worker class defines a single worker, idle or active:</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    broker_t *broker;           //  Broker instance</span><br><span class="line">    char *id_string;            //  Identity of worker as string</span><br><span class="line">    zframe_t *identity;         //  Identity frame for routing</span><br><span class="line">    service_t *service;         //  Owning service, if known</span><br><span class="line">    int64_t expiry;             //  When worker expires, if no heartbeat</span><br><span class="line">&#125; worker_t;</span><br><span class="line"></span><br><span class="line">static worker_t *</span><br><span class="line">    s_worker_require (broker_t *self, zframe_t *identity);</span><br><span class="line">static void</span><br><span class="line">    s_worker_delete (worker_t *self, int disconnect);</span><br><span class="line">static void</span><br><span class="line">    s_worker_destroy (void *argument);</span><br><span class="line">static void</span><br><span class="line">    s_worker_send (worker_t *self, char *command, char *option,</span><br><span class="line">                   zmsg_t *msg);</span><br><span class="line">static void</span><br><span class="line">    s_worker_waiting (worker_t *self);</span><br><span class="line"></span><br><span class="line">//  Here are the constructor and destructor for the broker:</span><br><span class="line"></span><br><span class="line">static broker_t *</span><br><span class="line">s_broker_new (int verbose)</span><br><span class="line">&#123;</span><br><span class="line">    broker_t *self = (broker_t *) zmalloc (sizeof (broker_t));</span><br><span class="line"></span><br><span class="line">    //  Initialize broker state</span><br><span class="line">    self-&gt;ctx = zctx_new ();</span><br><span class="line">    self-&gt;socket = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);</span><br><span class="line">    self-&gt;verbose = verbose;</span><br><span class="line">    self-&gt;services = zhash_new ();</span><br><span class="line">    self-&gt;workers = zhash_new ();</span><br><span class="line">    self-&gt;waiting = zlist_new ();</span><br><span class="line">    self-&gt;heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_broker_destroy (broker_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        broker_t *self = *self_p;</span><br><span class="line">        zctx_destroy (&amp;self-&gt;ctx);</span><br><span class="line">        zhash_destroy (&amp;self-&gt;services);</span><br><span class="line">        zhash_destroy (&amp;self-&gt;workers);</span><br><span class="line">        zlist_destroy (&amp;self-&gt;waiting);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method binds the broker instance to an endpoint. We can call</span><br><span class="line">//  this multiple times. Note that MDP uses a single socket for both clients</span><br><span class="line">//  and workers:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">s_broker_bind (broker_t *self, char *endpoint)</span><br><span class="line">&#123;</span><br><span class="line">    zsocket_bind (self-&gt;socket, endpoint);</span><br><span class="line">    zclock_log (&quot;I: MDP broker/0.2.0 is active at %s&quot;, endpoint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method processes one READY, REPLY, HEARTBEAT, or</span><br><span class="line">//  DISCONNECT message sent to the broker by a worker:</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_broker_worker_msg (broker_t *self, zframe_t *sender, zmsg_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">    assert (zmsg_size (msg) &gt;= 1);     //  At least, command</span><br><span class="line"></span><br><span class="line">    zframe_t *command = zmsg_pop (msg);</span><br><span class="line">    char *id_string = zframe_strhex (sender);</span><br><span class="line">    int worker_ready = (zhash_lookup (self-&gt;workers, id_string) != NULL);</span><br><span class="line">    free (id_string);</span><br><span class="line">    worker_t *worker = s_worker_require (self, sender);</span><br><span class="line"></span><br><span class="line">    if (zframe_streq (command, MDPW_READY)) &#123;</span><br><span class="line">        if (worker_ready)               //  Not first command in session</span><br><span class="line">            s_worker_delete (worker, 1);</span><br><span class="line">        else</span><br><span class="line">        if (zframe_size (sender) &gt;= 4  //  Reserved service name</span><br><span class="line">        &amp;&amp;  memcmp (zframe_data (sender), &quot;mmi.&quot;, 4) == 0)</span><br><span class="line">            s_worker_delete (worker, 1);</span><br><span class="line">        else &#123;</span><br><span class="line">            //  Attach worker to service and mark as idle</span><br><span class="line">            zframe_t *service_frame = zmsg_pop (msg);</span><br><span class="line">            worker-&gt;service = s_service_require (self, service_frame);</span><br><span class="line">            worker-&gt;service-&gt;workers++;</span><br><span class="line">            s_worker_waiting (worker);</span><br><span class="line">            zframe_destroy (&amp;service_frame);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    if (zframe_streq (command, MDPW_REPLY)) &#123;</span><br><span class="line">        if (worker_ready) &#123;</span><br><span class="line">            //  Remove and save client return envelope and insert the</span><br><span class="line">            //  protocol header and service name, then rewrap envelope.</span><br><span class="line">            zframe_t *client = zmsg_unwrap (msg);</span><br><span class="line">            zmsg_pushstr (msg, worker-&gt;service-&gt;name);</span><br><span class="line">            zmsg_pushstr (msg, MDPC_CLIENT);</span><br><span class="line">            zmsg_wrap (msg, client);</span><br><span class="line">            zmsg_send (&amp;msg, self-&gt;socket);</span><br><span class="line">            s_worker_waiting (worker);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            s_worker_delete (worker, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    if (zframe_streq (command, MDPW_HEARTBEAT)) &#123;</span><br><span class="line">        if (worker_ready)</span><br><span class="line">            worker-&gt;expiry = zclock_time () + HEARTBEAT_EXPIRY;</span><br><span class="line">        else</span><br><span class="line">            s_worker_delete (worker, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    if (zframe_streq (command, MDPW_DISCONNECT))</span><br><span class="line">        s_worker_delete (worker, 0);</span><br><span class="line">    else &#123;</span><br><span class="line">        zclock_log (&quot;E: invalid input message&quot;);</span><br><span class="line">        zmsg_dump (msg);</span><br><span class="line">    &#125;</span><br><span class="line">    free (command);</span><br><span class="line">    zmsg_destroy (&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Process a request coming from a client. We implement MMI requests</span><br><span class="line">//  directly here (at present, we implement only the mmi.service request):</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_broker_client_msg (broker_t *self, zframe_t *sender, zmsg_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">    assert (zmsg_size (msg) &gt;= 2);     //  Service name + body</span><br><span class="line"></span><br><span class="line">    zframe_t *service_frame = zmsg_pop (msg);</span><br><span class="line">    service_t *service = s_service_require (self, service_frame);</span><br><span class="line"></span><br><span class="line">    //  Set reply return identity to client sender</span><br><span class="line">    zmsg_wrap (msg, zframe_dup (sender));</span><br><span class="line"></span><br><span class="line">    //  If we got a MMI service request, process that internally</span><br><span class="line">    if (zframe_size (service_frame) &gt;= 4</span><br><span class="line">    &amp;&amp;  memcmp (zframe_data (service_frame), &quot;mmi.&quot;, 4) == 0) &#123;</span><br><span class="line">        char *return_code;</span><br><span class="line">        if (zframe_streq (service_frame, &quot;mmi.service&quot;)) &#123;</span><br><span class="line">            char *name = zframe_strdup (zmsg_last (msg));</span><br><span class="line">            service_t *service =</span><br><span class="line">                (service_t *) zhash_lookup (self-&gt;services, name);</span><br><span class="line">            return_code = service &amp;&amp; service-&gt;workers? &quot;200&quot;: &quot;404&quot;;</span><br><span class="line">            free (name);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return_code = &quot;501&quot;;</span><br><span class="line"></span><br><span class="line">        zframe_reset (zmsg_last (msg), return_code, strlen (return_code));</span><br><span class="line"></span><br><span class="line">        //  Remove &amp; save client return envelope and insert the</span><br><span class="line">        //  protocol header and service name, then rewrap envelope.</span><br><span class="line">        zframe_t *client = zmsg_unwrap (msg);</span><br><span class="line">        zmsg_push (msg, zframe_dup (service_frame));</span><br><span class="line">        zmsg_pushstr (msg, MDPC_CLIENT);</span><br><span class="line">        zmsg_wrap (msg, client);</span><br><span class="line">        zmsg_send (&amp;msg, self-&gt;socket);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        //  Else dispatch the message to the requested service</span><br><span class="line">        s_service_dispatch (service, msg);</span><br><span class="line">    zframe_destroy (&amp;service_frame);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method deletes any idle workers that haven&#x27;t pinged us in a</span><br><span class="line">//  while. We hold workers from oldest to most recent so we can stop</span><br><span class="line">//  scanning whenever we find a live worker. This means we&#x27;ll mainly stop</span><br><span class="line">//  at the first worker, which is essential when we have large numbers of</span><br><span class="line">//  workers (we call this method in our critical path):</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_broker_purge (broker_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    worker_t *worker = (worker_t *) zlist_first (self-&gt;waiting);</span><br><span class="line">    while (worker) &#123;</span><br><span class="line">        if (zclock_time () &lt; worker-&gt;expiry)</span><br><span class="line">            break;                  //  Worker is alive, we&#x27;re done here</span><br><span class="line">        if (self-&gt;verbose)</span><br><span class="line">            zclock_log (&quot;I: deleting expired worker: %s&quot;,</span><br><span class="line">                        worker-&gt;id_string);</span><br><span class="line"></span><br><span class="line">        s_worker_delete (worker, 0);</span><br><span class="line">        worker = (worker_t *) zlist_first (self-&gt;waiting);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here is the implementation of the methods that work on a service:</span><br><span class="line"></span><br><span class="line">//  Lazy constructor that locates a service by name or creates a new</span><br><span class="line">//  service if there is no service already with that name.</span><br><span class="line"></span><br><span class="line">static service_t *</span><br><span class="line">s_service_require (broker_t *self, zframe_t *service_frame)</span><br><span class="line">&#123;</span><br><span class="line">    assert (service_frame);</span><br><span class="line">    char *name = zframe_strdup (service_frame);</span><br><span class="line"></span><br><span class="line">    service_t *service =</span><br><span class="line">        (service_t *) zhash_lookup (self-&gt;services, name);</span><br><span class="line">    if (service == NULL) &#123;</span><br><span class="line">        service = (service_t *) zmalloc (sizeof (service_t));</span><br><span class="line">        service-&gt;broker = self;</span><br><span class="line">        service-&gt;name = name;</span><br><span class="line">        service-&gt;requests = zlist_new ();</span><br><span class="line">        service-&gt;waiting = zlist_new ();</span><br><span class="line">        zhash_insert (self-&gt;services, name, service);</span><br><span class="line">        zhash_freefn (self-&gt;services, name, s_service_destroy);</span><br><span class="line">        if (self-&gt;verbose)</span><br><span class="line">            zclock_log (&quot;I: added service: %s&quot;, name);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        free (name);</span><br><span class="line"></span><br><span class="line">    return service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Service destructor is called automatically whenever the service is</span><br><span class="line">//  removed from broker-&gt;services.</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_service_destroy (void *argument)</span><br><span class="line">&#123;</span><br><span class="line">    service_t *service = (service_t *) argument;</span><br><span class="line">    while (zlist_size (service-&gt;requests)) &#123;</span><br><span class="line">        zmsg_t *msg = zlist_pop (service-&gt;requests);</span><br><span class="line">        zmsg_destroy (&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    zlist_destroy (&amp;service-&gt;requests);</span><br><span class="line">    zlist_destroy (&amp;service-&gt;waiting);</span><br><span class="line">    free (service-&gt;name);</span><br><span class="line">    free (service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method sends requests to waiting workers:</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_service_dispatch (service_t *self, zmsg_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    if (msg)                    //  Queue message if any</span><br><span class="line">        zlist_append (self-&gt;requests, msg);</span><br><span class="line"></span><br><span class="line">    s_broker_purge (self-&gt;broker);</span><br><span class="line">    while (zlist_size (self-&gt;waiting) &amp;&amp; zlist_size (self-&gt;requests)) &#123;</span><br><span class="line">        worker_t *worker = zlist_pop (self-&gt;waiting);</span><br><span class="line">        zlist_remove (self-&gt;broker-&gt;waiting, worker);</span><br><span class="line">        zmsg_t *msg = zlist_pop (self-&gt;requests);</span><br><span class="line">        s_worker_send (worker, MDPW_REQUEST, NULL, msg);</span><br><span class="line">        zmsg_destroy (&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here is the implementation of the methods that work on a worker:</span><br><span class="line"></span><br><span class="line">//  Lazy constructor that locates a worker by identity, or creates a new</span><br><span class="line">//  worker if there is no worker already with that identity.</span><br><span class="line"></span><br><span class="line">static worker_t *</span><br><span class="line">s_worker_require (broker_t *self, zframe_t *identity)</span><br><span class="line">&#123;</span><br><span class="line">    assert (identity);</span><br><span class="line"></span><br><span class="line">    //  self-&gt;workers is keyed off worker identity</span><br><span class="line">    char *id_string = zframe_strhex (identity);</span><br><span class="line">    worker_t *worker =</span><br><span class="line">        (worker_t *) zhash_lookup (self-&gt;workers, id_string);</span><br><span class="line"></span><br><span class="line">    if (worker == NULL) &#123;</span><br><span class="line">        worker = (worker_t *) zmalloc (sizeof (worker_t));</span><br><span class="line">        worker-&gt;broker = self;</span><br><span class="line">        worker-&gt;id_string = id_string;</span><br><span class="line">        worker-&gt;identity = zframe_dup (identity);</span><br><span class="line">        zhash_insert (self-&gt;workers, id_string, worker);</span><br><span class="line">        zhash_freefn (self-&gt;workers, id_string, s_worker_destroy);</span><br><span class="line">        if (self-&gt;verbose)</span><br><span class="line">            zclock_log (&quot;I: registering new worker: %s&quot;, id_string);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        free (id_string);</span><br><span class="line">    return worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method deletes the current worker.</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_worker_delete (worker_t *self, int disconnect)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    if (disconnect)</span><br><span class="line">        s_worker_send (self, MDPW_DISCONNECT, NULL, NULL);</span><br><span class="line"></span><br><span class="line">    if (self-&gt;service) &#123;</span><br><span class="line">        zlist_remove (self-&gt;service-&gt;waiting, self);</span><br><span class="line">        self-&gt;service-&gt;workers--;</span><br><span class="line">    &#125;</span><br><span class="line">    zlist_remove (self-&gt;broker-&gt;waiting, self);</span><br><span class="line">    //  This implicitly calls s_worker_destroy</span><br><span class="line">    zhash_delete (self-&gt;broker-&gt;workers, self-&gt;id_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Worker destructor is called automatically whenever the worker is</span><br><span class="line">//  removed from broker-&gt;workers.</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_worker_destroy (void *argument)</span><br><span class="line">&#123;</span><br><span class="line">    worker_t *self = (worker_t *) argument;</span><br><span class="line">    zframe_destroy (&amp;self-&gt;identity);</span><br><span class="line">    free (self-&gt;id_string);</span><br><span class="line">    free (self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method formats and sends a command to a worker. The caller may</span><br><span class="line">//  also provide a command option, and a message payload:</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_worker_send (worker_t *self, char *command, char *option, zmsg_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">    msg = msg? zmsg_dup (msg): zmsg_new ();</span><br><span class="line"></span><br><span class="line">    //  Stack protocol envelope to start of message</span><br><span class="line">    if (option)</span><br><span class="line">        zmsg_pushstr (msg, option);</span><br><span class="line">    zmsg_pushstr (msg, command);</span><br><span class="line">    zmsg_pushstr (msg, MDPW_WORKER);</span><br><span class="line"></span><br><span class="line">    //  Stack routing envelope to start of message</span><br><span class="line">    zmsg_wrap (msg, zframe_dup (self-&gt;identity));</span><br><span class="line"></span><br><span class="line">    if (self-&gt;broker-&gt;verbose) &#123;</span><br><span class="line">        zclock_log (&quot;I: sending %s to worker&quot;,</span><br><span class="line">            mdps_commands [(int) *command]);</span><br><span class="line">        zmsg_dump (msg);</span><br><span class="line">    &#125;</span><br><span class="line">    zmsg_send (&amp;msg, self-&gt;broker-&gt;socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This worker is now waiting for work</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_worker_waiting (worker_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    //  Queue to broker and service waiting lists</span><br><span class="line">    assert (self-&gt;broker);</span><br><span class="line">    zlist_append (self-&gt;broker-&gt;waiting, self);</span><br><span class="line">    zlist_append (self-&gt;service-&gt;waiting, self);</span><br><span class="line">    self-&gt;expiry = zclock_time () + HEARTBEAT_EXPIRY;</span><br><span class="line">    s_service_dispatch (self-&gt;service, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Finally, here is the main task. We create a new broker instance and</span><br><span class="line">//  then process messages on the broker socket:</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line"></span><br><span class="line">    broker_t *self = s_broker_new (verbose);</span><br><span class="line">    s_broker_bind (self, &quot;tcp://*:5555&quot;);</span><br><span class="line"></span><br><span class="line">    //  Get and process messages forever or until interrupted</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmq_pollitem_t items [] = &#123;</span><br><span class="line">            &#123; self-&gt;socket,  0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">        int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);</span><br><span class="line">        if (rc == -1)</span><br><span class="line">            break;              //  Interrupted</span><br><span class="line"></span><br><span class="line">        //  Process next input message, if any</span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            zmsg_t *msg = zmsg_recv (self-&gt;socket);</span><br><span class="line">            if (!msg)</span><br><span class="line">                break;          //  Interrupted</span><br><span class="line">            if (self-&gt;verbose) &#123;</span><br><span class="line">                zclock_log (&quot;I: received message:&quot;);</span><br><span class="line">                zmsg_dump (msg);</span><br><span class="line">            &#125;</span><br><span class="line">            zframe_t *sender = zmsg_pop (msg);</span><br><span class="line">            zframe_t *empty  = zmsg_pop (msg);</span><br><span class="line">            zframe_t *header = zmsg_pop (msg);</span><br><span class="line"></span><br><span class="line">            if (zframe_streq (header, MDPC_CLIENT))</span><br><span class="line">                s_broker_client_msg (self, sender, msg);</span><br><span class="line">            else</span><br><span class="line">            if (zframe_streq (header, MDPW_WORKER))</span><br><span class="line">                s_broker_worker_msg (self, sender, msg);</span><br><span class="line">            else &#123;</span><br><span class="line">                zclock_log (&quot;E: invalid message:&quot;);</span><br><span class="line">                zmsg_dump (msg);</span><br><span class="line">                zmsg_destroy (&amp;msg);</span><br><span class="line">            &#125;</span><br><span class="line">            zframe_destroy (&amp;sender);</span><br><span class="line">            zframe_destroy (&amp;empty);</span><br><span class="line">            zframe_destroy (&amp;header);</span><br><span class="line">        &#125;</span><br><span class="line">        //  Disconnect and delete any expired workers</span><br><span class="line">        //  Send heartbeats to idle workers if needed</span><br><span class="line">        if (zclock_time () &gt; self-&gt;heartbeat_at) &#123;</span><br><span class="line">            s_broker_purge (self);</span><br><span class="line">            worker_t *worker = (worker_t *) zlist_first (self-&gt;waiting);</span><br><span class="line">            while (worker) &#123;</span><br><span class="line">                s_worker_send (worker, MDPW_HEARTBEAT, NULL, NULL);</span><br><span class="line">                worker = (worker_t *) zlist_next (self-&gt;waiting);</span><br><span class="line">            &#125;</span><br><span class="line">            self-&gt;heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (zctx_interrupted)</span><br><span class="line">        printf (&quot;W: interrupt received, shutting down…\n&quot;);</span><br><span class="line"></span><br><span class="line">    s_broker_destroy (&amp;self);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这是目前我们看到的最复杂的例子。大概500行代码。为了写这个并让它有某种程度的健壮性，用了我两天时间。然而，这仍是一个完整的面向服务中介的一小部分代码。</p>
<p>　　这里有一些关于它的说明：</p>
<ul>
<li>管家模型协议让我们能在一个单独的socket上管理client和worker。这对部署和管理中介相当友好：它只位于一个zmq的端点，而不是像大多数代理那样需要两个。</li>
<li>该中介正确实现了完整的MDP&#x2F;0.1(就我现在知道的)，包括在broker发送无效的命令、心跳或其他信息时候断开的处理。</li>
<li>可以将它扩展到在多线程上运行，每个线程管理一个socket和一套client与worker。这对分割大型架构可能有用。已经设计良好的围绕一个broker的类的C代码让这变得很容易。</li>
<li>一个主／备模型或者实时／实时broker的可靠模型也很容易实现，因为broker本质上来说除了服务出现就没有状态。如果在client和worker第一次没正确连接运行起来的时候，需要它们自己去选择另一个broker。</li>
<li>例子中使用了5秒的心跳，主要是为了让你在追踪的时候尽量少点儿输出。现实的值对大多说局域网应用来说可以低点儿。但，每次重试都必须足够慢，好让一个服务重启，比如说至少10秒。</li>
</ul>
<p>　　我们稍后改进扩展了该协议和管家模型的实现，现在在我们的Github项目上。如果你想正确使用管家模型，就看看GitHub上的项目吧。</p>
<p><strong>异步管家模型</strong></p>
<p>　　上节中实现的管家模型相当简单且愚蠢。client只是最开始简单海盗里边的，用一个性感的API封装了下。我才一台测试机上运行client，broker和worker的时候，大约１４秒能处理100,000请求。部分原因是因为代码问题，它经常到处复制message帧，就像CPU在空余一样。但真正的问题是我们正在做网络的双向回路。zmq没有用<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Nagles_algorithm">Nagle’s algorithm</a>，但双向回路仍然很慢。</p>
<p>　　理论总是理论，实践才是检验真理的唯一标准。我们用一个简单的测试程序度量一个双向回路的开销。它发送一组message，第一个等着每个message的一个回复，第二个作为一个批处理作业来一次读取所有的这些回复。两种方法做的事情是相同的，但结果很不一样。我们模拟一个client，一个broker和一个worker:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">//  tripping: Round-trip demonstrator in C</span><br><span class="line">//  Round-trip demonstrator</span><br><span class="line">//  While this example runs in a single process, that is just to make</span><br><span class="line">//  it easier to start and stop the example. The client task signals to</span><br><span class="line">//  main when it&#x27;s ready.</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">client_task (void *args, zctx_t *ctx, void *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    void *client = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    zsocket_connect (client, &quot;tcp://localhost:5555&quot;);</span><br><span class="line">    printf (&quot;Setting up test…\n&quot;);</span><br><span class="line">    zclock_sleep (100);</span><br><span class="line"></span><br><span class="line">    int requests;</span><br><span class="line">    int64_t start;</span><br><span class="line"></span><br><span class="line">    printf (&quot;Synchronous round-trip test…\n&quot;);</span><br><span class="line">    start = zclock_time ();</span><br><span class="line">    for (requests = 0; requests &lt; 10000; requests++) &#123;</span><br><span class="line">        zstr_send (client, &quot;hello&quot;);</span><br><span class="line">        char *reply = zstr_recv (client);</span><br><span class="line">        free (reply);</span><br><span class="line">    &#125;</span><br><span class="line">    printf (&quot; %d calls/second\n&quot;,</span><br><span class="line">        (1000 * 10000) / (int) (zclock_time () - start));</span><br><span class="line"></span><br><span class="line">    printf (&quot;Asynchronous round-trip test…\n&quot;);</span><br><span class="line">    start = zclock_time ();</span><br><span class="line">    for (requests = 0; requests &lt; 100000; requests++)</span><br><span class="line">        zstr_send (client, &quot;hello&quot;);</span><br><span class="line">    for (requests = 0; requests &lt; 100000; requests++) &#123;</span><br><span class="line">        char *reply = zstr_recv (client);</span><br><span class="line">        free (reply);</span><br><span class="line">    &#125;</span><br><span class="line">    printf (&quot; %d calls/second\n&quot;,</span><br><span class="line">        (1000 * 100000) / (int) (zclock_time () - start));</span><br><span class="line">    zstr_send (pipe, &quot;done&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here is the worker task. All it does is receive a message, and</span><br><span class="line">//  bounce it back the way it came:</span><br><span class="line"></span><br><span class="line">static void *</span><br><span class="line">worker_task (void *args)</span><br><span class="line">&#123;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *worker = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    zsocket_connect (worker, &quot;tcp://localhost:5556&quot;);</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmsg_t *msg = zmsg_recv (worker);</span><br><span class="line">        zmsg_send (&amp;msg, worker);</span><br><span class="line">    &#125;</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here is the broker task. It uses the zmq_proxy function to switch</span><br><span class="line">//  messages between frontend and backend:</span><br><span class="line"></span><br><span class="line">static void *</span><br><span class="line">broker_task (void *args)</span><br><span class="line">&#123;</span><br><span class="line">    //  Prepare our context and sockets</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *frontend = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    zsocket_bind (frontend, &quot;tcp://*:5555&quot;);</span><br><span class="line">    void *backend = zsocket_new (ctx, ZMQ_DEALER);</span><br><span class="line">    zsocket_bind (backend, &quot;tcp://*:5556&quot;);</span><br><span class="line">    zmq_proxy (frontend, backend, NULL);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Finally, here&#x27;s the main task, which starts the client, worker, and</span><br><span class="line">//  broker, and then runs until the client signals it to stop:</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    //  Create threads</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *client = zthread_fork (ctx, client_task, NULL);</span><br><span class="line">    zthread_new (worker_task, NULL);</span><br><span class="line">    zthread_new (broker_task, NULL);</span><br><span class="line"></span><br><span class="line">    //  Wait for signal on client pipe</span><br><span class="line">    char *signal = zstr_recv (client);</span><br><span class="line">    free (signal);</span><br><span class="line"></span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在我的开发机器上，结果显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Setting up test...</span><br><span class="line">Synchronous round-trip test...</span><br><span class="line"> 9057 calls/second</span><br><span class="line">Asynchronous round-trip test...</span><br><span class="line"> 173010 calls/second</span><br></pre></td></tr></table></figure>
<p>　　注意client线程在启动前有一个小停留，这是为了避免ROUTER socket的一个”特性”：如果你在发送信息的时候还没跟对端建立连接，那信息就会丢掉。这个例子中我们没有使用负载均衡机制，也就没有睡眠，如果worker线程接入得太慢，他就会丢失message，而把我们的测试毁掉。</p>
<p>　　就像我们看到的那样，在最简单的例子中双向回路要比异步模型慢近20倍，异步模型就是”尽量把它往管道里推”。让我们看看是否能把它应用到管家模型让管家模型更快不能。</p>
<p>　　首先，我们先调整client的API让发送和接收分在两个单独的方法中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mdcli_t *mdcli_new     (char *broker);</span><br><span class="line">void     mdcli_destroy (mdcli_t **self_p);</span><br><span class="line">int      mdcli_send    (mdcli_t *self, char *service, zmsg_t **request_p);</span><br><span class="line">zmsg_t  *mdcli_recv    (mdcli_t *self);</span><br></pre></td></tr></table></figure>
<p>　　真的只要花很少时间就能把同步的client的API重构成异步的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">//  mdcliapi2: Majordomo asynchronuous clinet API in C</span><br><span class="line">//  mdcliapi2 class - Majordomo Protocol Client API</span><br><span class="line">//  Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.</span><br><span class="line"></span><br><span class="line">#include &quot;mdcliapi2.h&quot;</span><br><span class="line"></span><br><span class="line">//  Structure of our class</span><br><span class="line">//  We access these properties only via class methods</span><br><span class="line"></span><br><span class="line">struct _mdcli_t &#123;</span><br><span class="line">    zctx_t *ctx;                //  Our context</span><br><span class="line">    char *broker;</span><br><span class="line">    void *client;               //  Socket to broker</span><br><span class="line">    int verbose;                //  Print activity to stdout</span><br><span class="line">    int timeout;                //  Request timeout</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  Connect or reconnect to broker. In this asynchronous class we use a</span><br><span class="line">//  DEALER socket instead of a REQ socket; this lets us send any number</span><br><span class="line">//  of requests without waiting for a reply.</span><br><span class="line"></span><br><span class="line">void s_mdcli_connect_to_broker (mdcli_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    if (self-&gt;client)</span><br><span class="line">        zsocket_destroy (self-&gt;ctx, self-&gt;client);</span><br><span class="line">    self-&gt;client = zsocket_new (self-&gt;ctx, ZMQ_DEALER);</span><br><span class="line">    zmq_connect (self-&gt;client, self-&gt;broker);</span><br><span class="line">    if (self-&gt;verbose)</span><br><span class="line">        zclock_log (&quot;I: connecting to broker at %s…&quot;, self-&gt;broker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The constructor and destructor are the same as in mdcliapi, except</span><br><span class="line">//  we don&#x27;t do retries, so there&#x27;s no retries property.</span><br><span class="line">//  ---------------------------------------------------------------------</span><br><span class="line">//  Constructor</span><br><span class="line"></span><br><span class="line">mdcli_t *</span><br><span class="line">mdcli_new (char *broker, int verbose)</span><br><span class="line">&#123;</span><br><span class="line">    assert (broker);</span><br><span class="line"></span><br><span class="line">    mdcli_t *self = (mdcli_t *) zmalloc (sizeof (mdcli_t));</span><br><span class="line">    self-&gt;ctx = zctx_new ();</span><br><span class="line">    self-&gt;broker = strdup (broker);</span><br><span class="line">    self-&gt;verbose = verbose;</span><br><span class="line">    self-&gt;timeout = 2500;           //  msecs</span><br><span class="line"></span><br><span class="line">    s_mdcli_connect_to_broker (self);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Destructor</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">mdcli_destroy (mdcli_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        mdcli_t *self = *self_p;</span><br><span class="line">        zctx_destroy (&amp;self-&gt;ctx);</span><br><span class="line">        free (self-&gt;broker);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Set request timeout</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">mdcli_set_timeout (mdcli_t *self, int timeout)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    self-&gt;timeout = timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The send method now just sends one message, without waiting for a</span><br><span class="line">//  reply. Since we&#x27;re using a DEALER socket we have to send an empty</span><br><span class="line">//  frame at the start, to create the same envelope that the REQ socket</span><br><span class="line">//  would normally make for us:</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">mdcli_send (mdcli_t *self, char *service, zmsg_t **request_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    assert (request_p);</span><br><span class="line">    zmsg_t *request = *request_p;</span><br><span class="line"></span><br><span class="line">    //  Prefix request with protocol frames</span><br><span class="line">    //  Frame 0: empty (REQ emulation)</span><br><span class="line">    //  Frame 1: &quot;MDPCxy&quot; (six bytes, MDP/Client x.y)</span><br><span class="line">    //  Frame 2: Service name (printable string)</span><br><span class="line">    zmsg_pushstr (request, service);</span><br><span class="line">    zmsg_pushstr (request, MDPC_CLIENT);</span><br><span class="line">    zmsg_pushstr (request, &quot;&quot;);</span><br><span class="line">    if (self-&gt;verbose) &#123;</span><br><span class="line">        zclock_log (&quot;I: send request to &#x27;%s&#x27; service:&quot;, service);</span><br><span class="line">        zmsg_dump (request);</span><br><span class="line">    &#125;</span><br><span class="line">    zmsg_send (&amp;request, self-&gt;client);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The recv method waits for a reply message and returns that to the</span><br><span class="line">//  caller.</span><br><span class="line">//  ---------------------------------------------------------------------</span><br><span class="line">//  Returns the reply message or NULL if there was no reply. Does not</span><br><span class="line">//  attempt to recover from a broker failure, this is not possible</span><br><span class="line">//  without storing all unanswered requests and resending them all…</span><br><span class="line"></span><br><span class="line">zmsg_t *</span><br><span class="line">mdcli_recv (mdcli_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line"></span><br><span class="line">    //  Poll socket for a reply, with timeout</span><br><span class="line">    zmq_pollitem_t items [] = &#123; &#123; self-&gt;client, 0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">    int rc = zmq_poll (items, 1, self-&gt;timeout * ZMQ_POLL_MSEC);</span><br><span class="line">    if (rc == -1)</span><br><span class="line">        return NULL;            //  Interrupted</span><br><span class="line"></span><br><span class="line">    //  If we got a reply, process it</span><br><span class="line">    if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">        zmsg_t *msg = zmsg_recv (self-&gt;client);</span><br><span class="line">        if (self-&gt;verbose) &#123;</span><br><span class="line">            zclock_log (&quot;I: received reply:&quot;);</span><br><span class="line">            zmsg_dump (msg);</span><br><span class="line">        &#125;</span><br><span class="line">        //  Don&#x27;t try to handle errors, just assert noisily</span><br><span class="line">        assert (zmsg_size (msg) &gt;= 4);</span><br><span class="line"></span><br><span class="line">        zframe_t *empty = zmsg_pop (msg);</span><br><span class="line">        assert (zframe_streq (empty, &quot;&quot;));</span><br><span class="line">        zframe_destroy (&amp;empty);</span><br><span class="line"></span><br><span class="line">        zframe_t *header = zmsg_pop (msg);</span><br><span class="line">        assert (zframe_streq (header, MDPC_CLIENT));</span><br><span class="line">        zframe_destroy (&amp;header);</span><br><span class="line"></span><br><span class="line">        zframe_t *service = zmsg_pop (msg);</span><br><span class="line">        zframe_destroy (&amp;service);</span><br><span class="line"></span><br><span class="line">        return msg;     //  Success</span><br><span class="line">    &#125;</span><br><span class="line">    if (zctx_interrupted)</span><br><span class="line">        printf (&quot;W: interrupt received, killing client…\n&quot;);</span><br><span class="line">    else</span><br><span class="line">    if (self-&gt;verbose)</span><br><span class="line">        zclock_log (&quot;W: permanent error, abandoning request&quot;);</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　不同之处为：</p>
<ul>
<li>我们用一个DEALER socket替换掉REQ，所以我们需要在每个请求和回复的message开始模拟一个REQ的空分割帧。</li>
<li>我们不会重发请求。如果应用需要重试，它就会自己做。</li>
<li>我们把同步的<code>send</code>方法拆分成了独立的<code>send</code>和<code>recv</code>方法。</li>
<li>改进的<code>send</code>是异步的，发送之后会立即收到回复。所以调用者能在收到回复之前发送很多message。</li>
<li><code>recv</code>方法等待(有超时时间)一个回复然后返回给调用者。</li>
</ul>
<p>　　下面是对应的client测试程序，它会发送100,000条message然后收到100,000条回复：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//  mdclinet2: Majordomo client application in C</span><br><span class="line">//  Majordomo Protocol client example - asynchronous</span><br><span class="line">//  Uses the mdcli API to hide all MDP aspects</span><br><span class="line"></span><br><span class="line">//  Lets us build this source without creating a library</span><br><span class="line">#include &quot;mdcliapi2.c&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line">    mdcli_t *session = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);</span><br><span class="line"></span><br><span class="line">    int count;</span><br><span class="line">    for (count = 0; count &lt; 100000; count++) &#123;</span><br><span class="line">        zmsg_t *request = zmsg_new ();</span><br><span class="line">        zmsg_pushstr (request, &quot;Hello world&quot;);</span><br><span class="line">        mdcli_send (session, &quot;echo&quot;, &amp;request);</span><br><span class="line">    &#125;</span><br><span class="line">    for (count = 0; count &lt; 100000; count++) &#123;</span><br><span class="line">        zmsg_t *reply = mdcli_recv (session);</span><br><span class="line">        if (reply)</span><br><span class="line">            zmsg_destroy (&amp;reply);</span><br><span class="line">        else</span><br><span class="line">            break;              //  Interrupted by Ctrl-C</span><br><span class="line">    &#125;</span><br><span class="line">    printf (&quot;%d replies received\n&quot;, count);</span><br><span class="line">    mdcli_destroy (&amp;session);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　broker和worker没变因为我们一点儿都没改动协议。我们会看到性能上的显著提升。下面是同步的client处理100k请求－回复循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ time mdclient</span><br><span class="line">100000 requests/replies processed</span><br><span class="line"></span><br><span class="line">real    0m14.088s</span><br><span class="line">user    0m1.310s</span><br><span class="line">sys     0m2.670s</span><br></pre></td></tr></table></figure>
<p>　　下面是异步的client，和一个单独的worker：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ time mdclient2</span><br><span class="line">100000 replies received</span><br><span class="line"></span><br><span class="line">real    0m8.730s</span><br><span class="line">user    0m0.920s</span><br><span class="line">sys     0m1.550s</span><br></pre></td></tr></table></figure>
<p>　　快了两倍。不是很糟糕，但我们启动10个worker可以看到提升了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ time mdclient2</span><br><span class="line">100000 replies received</span><br><span class="line"></span><br><span class="line">real    0m3.863s</span><br><span class="line">user    0m0.730s</span><br><span class="line">sys     0m0.470s</span><br></pre></td></tr></table></figure>
<p>　　它并不是全异步的，因为worker以严格的最后使用顺序来拿到message。但对更多的worker来说它扩展起来更好。在我的PC机上，８个或更多wokrer之后，处理速度就不会提升更快了。四核机器只能扩展成这样了。但通过几分钟的工作，我们就得到了4倍的性能提升。broker还没优化，它花费了大量的时间去到处复制message的帧，而不是使用零拷贝。但我们会用相当少的努力来获取高达每秒25K次可靠的请求／回复处理。</p>
<p>　　然而，异步的管家模型也不总是好用。他有个致命的弱点，就是没有更多代码的话它没办法处理broker崩溃。如果你详细看了mdcliapi2的代码，你就会发现它在故障后没有尝试去重连。一个合适的重连机制需要以下这些东西：</p>
<ul>
<li>附带一个编号的请求和对应编号的回复，这个可以通过更改协议来实现。</li>
<li>记录所有在client　API出去的请求，比如说，所有还没收到回复的请求。</li>
<li>故障发生的时候，client　API负责<em>重新发送</em>所有记录的请求。</li>
</ul>
<p>　　它并不是一个协议破坏者，但确实显示了性能通常意味着复杂。使用管家模型是否值得呢？这要依据你的使用场景，在那些每个会话只用一次的名字查询服务中是不合适的，但对服务成千个client的web前端来说，可能就是合适的。</p>
<p><strong>服务发现</strong></p>
<p>　　我们现在有了一个很好的面向服务的broker，但还没办法知道一个特定的服务是否存在。我们知道一个请求是否失败了，但不知道为什么失败。如果能问broker就很有用了，”echo服务还在运行吗？”最明显的办法就是修改我们的MDP&#x2F;Clinet协议来增加询问的命令。但MDP&#x2F;Client有着迷人的简单性。增加服务发现会让它跟MDP&#x2F;Worker协议一样复杂。</p>
<p>　　另一个选择是学习email做的那样，要求把不能递送的请求给退回来。这在一个异步模型中能很好工作，只是也要增加复杂性。我们需要能从回复的信息中分辨出来那些是退回的请求，并且正确处理它们。</p>
<p>　　让我们用已经有的设计，在MDP之上设计而不是去修改它。服务发现本身也是一个服务。他可能是很多管理服务(比如”禁掉服务X”，”提供统计数据”等)其中的一个。我们想要的是一种通用的可扩展的解决方案，而不影响现有的协议和应用。</p>
<p>　　所以在MDP之上有个小的RFC：<a target="_blank" rel="noopener" href="http://rfc.zeromq.org/spec:8">管家模型管理接口 the Majordomo Management Interface(MMI)</a>。我们已经在broekr中实现了它，但除非你读了所有的东西，很可能你会错过它。我来解释一下在broker中他是怎么工作的:</p>
<ul>
<li>一个client请求服务的时候先发送到mmi。，而不是路由到一个worker，我们会在内部处理路由方向的。</li>
<li>我们只在broker中维持一个服务，就是mmi.服务，服务发现服务。</li>
<li>请求的有效负载是额外服务的名字(真正的服务名字，由worker提供)。</li>
<li>根据是否有worker注册了这项服务，broker返回”200”(OK)或者”404”(未发现服务)</li>
</ul>
<p>　　下面是我们在应用中怎么使用服务发现机制的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//  mmiecho: Service discovery over Majordomo in C</span><br><span class="line">//  MMI echo query example</span><br><span class="line"></span><br><span class="line">//  Lets us build this source without creating a library</span><br><span class="line">#include &quot;mdcliapi.c&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line">    mdcli_t *session = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);</span><br><span class="line"></span><br><span class="line">    //  This is the service we want to look up</span><br><span class="line">    zmsg_t *request = zmsg_new ();</span><br><span class="line">    zmsg_addstr (request, &quot;echo&quot;);</span><br><span class="line"></span><br><span class="line">    //  This is the service we send our request to</span><br><span class="line">    zmsg_t *reply = mdcli_send (session, &quot;mmi.service&quot;, &amp;request);</span><br><span class="line"></span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        char *reply_code = zframe_strdup (zmsg_first (reply));</span><br><span class="line">        printf (&quot;Lookup echo service: %s\n&quot;, reply_code);</span><br><span class="line">        free (reply_code);</span><br><span class="line">        zmsg_destroy (&amp;reply);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        printf (&quot;E: no response from broker, make sure it&#x27;s running\n&quot;);</span><br><span class="line"></span><br><span class="line">    mdcli_destroy (&amp;session);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在运行和不运行worker的时候试试该测试，你会发现这个小程序会相应报告”200”或者”404”。在我们的例子broker中实现的MMI相当脆弱。例如，如果一个worker退出，server还保持”存在”。在实际中，broker应该在可配置的超时时间后仍没有worker就把该项服务给移除。</p>
<p><strong>幂等服务</strong></p>
<p>  Idempotency is not something you take a pill for.它的意思是重复一个操作是安全的。检查时间是幂等的。把信用卡借给一个小孩子不是幂等的。尽管有很多client-to-server的使用情况是幂等的，但还有些不是。幂等的应用场景包括：</p>
<ul>
<li>无状态的任务分发，比如说一个管道中的server是无状态的，worker单纯依赖一个请求提供的状态来计算出回复。在这个场景中，多次计算同一个请求是安全的(尽管效率不高)。</li>
<li>一个把逻辑地址转换成端点地址去绑定或者连接的名字查找服务。在这个场景中，多次查找相同的名字是安全的。</li>
</ul>
<p>　　下面是一些不幂等的应用场景：</p>
<ul>
<li>登陆服务。人们不希望多次输入相同的登陆信息。</li>
<li>任何对下游节点有影响的服务，比如说传递信息到其他节点。如果服务多次拿到相同的请求，下游节点就会得到重复的信息。</li>
<li>任何使用不幂等方法修改共享信息的服务，比如说，银行借出账户如果没有额外的处理那它就是不幂等的服务。</li>
</ul>
<p>　　在我们的服务器应用不是幂等的情况下，我们必须对它们什么时候可能崩溃要思考更多。如果一个应用在它空闲的时候挂掉，或者在处理请求的时候挂掉，通常是好的。我们可以用一个数据库事务去保证一个账户和信用卡总是一致的。如果服务器在发送回复的时候挂掉了，这就是个问题了，因为它以为它已经做好了自己的工作。</p>
<p>　　如果在回复要发送到client的时候网络挂掉，相同的问题也会出现。client会以为server死掉了然后重新发送请求，server就会做两次相同的工作，这是我们不想看到的。</p>
<p>　　要处理非幂等操作，可以使用以下相对标准的解决方案去检测和拒绝重复请求：</p>
<ul>
<li>client必须为每个请求都加一个基于唯一client标识和唯一message序号的标签。</li>
<li>server在返回回复之前，需要先用client ID和message序号的组合作为键来存储该请求标签。</li>
<li>server在收到一个特定client的请求的时候，先检查是否有针对该client ID和message需要的回复，如果有，就不去处理请求，直接返回该回复。</li>
</ul>
<p><strong>非连接可靠性(泰坦尼克模型 Titanic Pattern)</strong></p>
<p>　　一旦你意识到管家模型是一个”可靠的”message broker的时候，你可能想去添加一些spinning rust（译注：硬盘？）(that is, ferrous-based hard disk platters)。毕竟，broker是要为整个消息系统服务的。这是个有诱惑力的想法，不过很伤感的说必须否决掉它。但简单粗暴是我的一个特长(译注：orz….　　But brutal cynicism is one of my specialties)。因此，你不想在你的架构中加入持久化保障的一些原因是：</p>
<ul>
<li>就像你看到的那样，懒海盗模型工作的非常好。它贯穿了整个架构范围，从直接的client-to-server到分布式的队列代理。它确实假设了worker都是无状态的和幂等的。但我们可以不用求助持久化(rust感觉是翻译错了，我会在使用rust的地方都标注出来)就跨过该限制。</li>
<li>持久化(rust)会带来很多问题，从性能慢到必须增加格外的部分去管理、维护。海盗模型的美妙之处就在于它们非常简单。它们不会崩溃。如果你仍的担心硬件，你可以换成一个peer-to-peer模型，这根本就没中介了。我会在本章稍后部分解释这个模型。</li>
</ul>
<p>　　虽然这样说，但还是有需要持久化(rust)为基础的可靠性的应用场景的，就是在异步分连接网络中。它解决了海盗模型的一个重要问题，就是client必须实时等着回复。如果一个client和worker只是偶尔连接一下(比如email)，我们不能在client和worker之间使用无状态的网络连接，而必须把状态放在中间某个位置。</p>
<p>　　所以，这里就有了泰坦尼克模型，这里不管client和worker多偶然的连接，我们都会把message都写入磁盘来保证它们不会丢失。就像为服务发现做的那样，我们会在MDP之上构建泰坦尼克模型而不是扩展MDP。这非常简单，因为它意味着我们可以在一个特别的worker上实现我们的无人看守(fire-and-forget,巡航导弹发射后自动寻找目标，不用人看管)可靠性，而不是在broker中去实现。这很好，因为：</p>
<ul>
<li>它<em>非常</em>简单，因为分治：broker处理message路由，worker处理可靠性。</li>
<li>它能让我们混合起来，broker用一种语言去写，worker用另一种语言。</li>
<li>它让我们独立的开发无人看守技术。</li>
</ul>
<p>　　唯一的不足是需要额外的网络接口连接broker和硬盘，但跟好处相比是值得的。</p>
<p>　　有很多方法去设计一个持久化的请求－回复框架。我们的目标是简单且无痛苦的那一个。我想了几个小时之后觉得能设计出来的最简单的设计是”代理服务”。也就是说，泰坦尼克一点儿不会影响worker。如果一个client想立即得到回复，它会直接跟服务通信并希望服务可用。如果一个client能等一会儿的话，那它就可以去跟泰坦尼克说”嘿，伙计，能帮我看下这条信息吗，我去买点儿东西？”</p>
<p><img src="/img/zmq51.png" alt="f51"></p>
<p>　　因此，泰坦尼克号既是worker又是一个client。在client和泰坦尼克之间的会话流向如下：</p>
<ul>
<li>Client：请接收这个请求。Titanic:　OK，好了。</li>
<li>Client：你有给我的回复了吗？Titanic:　是的，在这里。或者不，还没。</li>
<li>Client：好了，现在你可以清空那个请求了，我很高兴。Titanic:　OK，好了。</li>
</ul>
<p>　　在Titanic和broker和worker之间的会话流向如下：</p>
<ul>
<li>Titanic:　嘿，broker，有个咖啡服务吗？ Broker：呃，好像有。</li>
<li>Titanic:　嘿，咖啡服务，帮我处理下这个。</li>
<li>Coffee：当然，这是结果。</li>
<li>Titanic:　真好！</li>
</ul>
<p>　　你可能遇到一些故障的情况。如果一个worker在处理请求的时候崩溃了，Titanic会无限重试。如果一个回复在某个地方丢了，Titanic也会重试。如果请求得到了处理但client并没收到回复，它会再发一遍请求。如果Titanic在处理请求或者回复的时候崩溃了，client会重试。只要请求被完整提交到了安全的储存位置，任务就不会丢失了。</p>
<p>　　握手过程相当迂腐，但也可以是流水线式的，比如，client可以用异步的管家模型去做很多工作，稍后才拿到回复。</p>
<p>　　我们需要某种方式让一个client得到<em>它自己的</em>回复。我们会有很多client去查询相同的服务，并且client伴随不同的标识掉线和上线。这里有个简单且相对安全的解决办法：</p>
<ul>
<li>每个请求生成一个唯一的ID(universally unique ID, UUID)，在Titanic把请求加入队列之后会把该UUID返回给client。</li>
<li>当一个client需要回复的时候，它必须给出原来那个请求的UUID。</li>
</ul>
<p>　　在实际应用中，client可能想安全的存储UUID，比如放到一个本地数据库里。</p>
<p>　　在我们跳过该部分去写另一个规范的说明的时候，先来看看client怎么跟Titanic通信的。一种方法是使用一个单独的服务，发送三种不同的请求类型。另一种相对简单一点儿的方法是使用三个服务：</p>
<ul>
<li>titanic.request:储存一个请求message，返回该请求的UUID。</li>
<li>titanic.reply:如果可能，就获取一个指定请求的UUID的回复。</li>
<li>titanic.close:确保回复已经存储并被处理过了。</li>
</ul>
<p>　　我们会设计一个多线程的worker，我么已经看到了用zmq设计多线程是很简单的事。但是，让我们先描述一下用zmq的message和帧怎么去表述Titanic。这给了我们<a target="_blank" rel="noopener" href="http://rfc.zeromq.org/spec:9">泰坦尼克服务协议 Titanic Service Protocol(TSP)</a>。</p>
<p>　　对client来说跟服务通信使用TSP显然要比直接用MDP要麻烦的多。下面是个最短的健壮的”echo”client例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//  ticlient: Titanic client example in C</span><br><span class="line">//  Titanic client example</span><br><span class="line">//  Implements client side of http://rfc.zeromq.org/spec:9</span><br><span class="line"></span><br><span class="line">//  Lets build this source without creating a library</span><br><span class="line">#include &quot;mdcliapi.c&quot;</span><br><span class="line"></span><br><span class="line">//  Calls a TSP service</span><br><span class="line">//  Returns response if successful (status code 200 OK), else NULL</span><br><span class="line">//</span><br><span class="line">static zmsg_t *</span><br><span class="line">s_service_call (mdcli_t *session, char *service, zmsg_t **request_p)</span><br><span class="line">&#123;</span><br><span class="line">    zmsg_t *reply = mdcli_send (session, service, request_p);</span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        zframe_t *status = zmsg_pop (reply);</span><br><span class="line">        if (zframe_streq (status, &quot;200&quot;)) &#123;</span><br><span class="line">            zframe_destroy (&amp;status);</span><br><span class="line">            return reply;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (zframe_streq (status, &quot;400&quot;)) &#123;</span><br><span class="line">            printf (&quot;E: client fatal error, aborting\n&quot;);</span><br><span class="line">            exit (EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (zframe_streq (status, &quot;500&quot;)) &#123;</span><br><span class="line">            printf (&quot;E: server fatal error, aborting\n&quot;);</span><br><span class="line">            exit (EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        exit (EXIT_SUCCESS);    //  Interrupted or failed</span><br><span class="line"></span><br><span class="line">    zmsg_destroy (&amp;reply);</span><br><span class="line">    return NULL;        //  Didn&#x27;t succeed; don&#x27;t care why not</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The main task tests our service call by sending an echo request:</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line">    mdcli_t *session = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);</span><br><span class="line"></span><br><span class="line">    //  1. Send &#x27;echo&#x27; request to Titanic</span><br><span class="line">    zmsg_t *request = zmsg_new ();</span><br><span class="line">    zmsg_addstr (request, &quot;echo&quot;);</span><br><span class="line">    zmsg_addstr (request, &quot;Hello world&quot;);</span><br><span class="line">    zmsg_t *reply = s_service_call (</span><br><span class="line">        session, &quot;titanic.request&quot;, &amp;request);</span><br><span class="line"></span><br><span class="line">    zframe_t *uuid = NULL;</span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        uuid = zmsg_pop (reply);</span><br><span class="line">        zmsg_destroy (&amp;reply);</span><br><span class="line">        zframe_print (uuid, &quot;I: request UUID &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //  2. Wait until we get a reply</span><br><span class="line">    while (!zctx_interrupted) &#123;</span><br><span class="line">        zclock_sleep (100);</span><br><span class="line">        request = zmsg_new ();</span><br><span class="line">        zmsg_add (request, zframe_dup (uuid));</span><br><span class="line">        zmsg_t *reply = s_service_call (</span><br><span class="line">            session, &quot;titanic.reply&quot;, &amp;request);</span><br><span class="line"></span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            char *reply_string = zframe_strdup (zmsg_last (reply));</span><br><span class="line">            printf (&quot;Reply: %s\n&quot;, reply_string);</span><br><span class="line">            free (reply_string);</span><br><span class="line">            zmsg_destroy (&amp;reply);</span><br><span class="line"></span><br><span class="line">            //  3. Close request</span><br><span class="line">            request = zmsg_new ();</span><br><span class="line">            zmsg_add (request, zframe_dup (uuid));</span><br><span class="line">            reply = s_service_call (session, &quot;titanic.close&quot;, &amp;request);</span><br><span class="line">            zmsg_destroy (&amp;reply);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            printf (&quot;I: no reply yet, trying again…\n&quot;);</span><br><span class="line">            zclock_sleep (5000);     //  Try again in 5 seconds</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zframe_destroy (&amp;uuid);</span><br><span class="line">    mdcli_destroy (&amp;session);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　当然，这可以也应该被封装起来成为某种框架或者API。要求一般的应用开发者去学习整个消息传输的细节是不好的：这会伤害它们的大脑，浪费时间，需要大量的工作维护很多问题的复杂性。另外，很难扩展。</p>
<p>　　例如，在实际应用中client会在每个请求上都阻塞，我们更希望在执行任务的时候做一些有用的事。这需要谨慎设计一个跟client干净利索的通信的后台线程。这是你希望封装在一个良好的简单的API里的东西，不会让普通的开发者用错。这同样是我们用来设计管家模型的方法。</p>
<p>　　下面是泰坦尼克模型的实现。server使用三个线程处理三种服务。它使用的应该是最暴力的方法来保存全部的信息：每条message一个文件。这相当简单，但也相当可怕。唯一复杂的部分是它维护了一个所有请求的队列，这是为了避免一次次从文件中读取信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line">//  titanic: Titanic broker example in C</span><br><span class="line">//  Titanic service</span><br><span class="line">//  Implements server side of http://rfc.zeromq.org/spec:9</span><br><span class="line"></span><br><span class="line">//  Lets us build this source without creating a library</span><br><span class="line">#include &quot;mdwrkapi.c&quot;</span><br><span class="line">#include &quot;mdcliapi.c&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;zfile.h&quot;</span><br><span class="line">#include &lt;uuid/uuid.h&gt;</span><br><span class="line"></span><br><span class="line">//  Return a new UUID as a printable character string</span><br><span class="line">//  Caller must free returned string when finished with it</span><br><span class="line"></span><br><span class="line">static char *</span><br><span class="line">s_generate_uuid (void)</span><br><span class="line">&#123;</span><br><span class="line">    char hex_char [] = &quot;0123456789ABCDEF&quot;;</span><br><span class="line">    char *uuidstr = zmalloc (sizeof (uuid_t) * 2 + 1);</span><br><span class="line">    uuid_t uuid;</span><br><span class="line">    uuid_generate (uuid);</span><br><span class="line">    int byte_nbr;</span><br><span class="line">    for (byte_nbr = 0; byte_nbr &lt; sizeof (uuid_t); byte_nbr++) &#123;</span><br><span class="line">        uuidstr [byte_nbr * 2 + 0] = hex_char [uuid [byte_nbr] &gt;&gt; 4];</span><br><span class="line">        uuidstr [byte_nbr * 2 + 1] = hex_char [uuid [byte_nbr] &amp; 15];</span><br><span class="line">    &#125;</span><br><span class="line">    return uuidstr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Returns freshly allocated request filename for given UUID</span><br><span class="line"></span><br><span class="line">#define TITANIC_DIR &quot;.titanic&quot;</span><br><span class="line"></span><br><span class="line">static char *</span><br><span class="line">s_request_filename (char *uuid) &#123;</span><br><span class="line">    char *filename = malloc (256);</span><br><span class="line">    snprintf (filename, 256, TITANIC_DIR &quot;/%s.req&quot;, uuid);</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Returns freshly allocated reply filename for given UUID</span><br><span class="line"></span><br><span class="line">static char *</span><br><span class="line">s_reply_filename (char *uuid) &#123;</span><br><span class="line">    char *filename = malloc (256);</span><br><span class="line">    snprintf (filename, 256, TITANIC_DIR &quot;/%s.rep&quot;, uuid);</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The titanic.request task waits for requests to this service. It writes</span><br><span class="line">//  each request to disk and returns a UUID to the client. The client picks</span><br><span class="line">//  up the reply asynchronously using the titanic.reply service:</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">titanic_request (void *args, zctx_t *ctx, void *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    mdwrk_t *worker = mdwrk_new (</span><br><span class="line">        &quot;tcp://localhost:5555&quot;, &quot;titanic.request&quot;, 0);</span><br><span class="line">    zmsg_t *reply = NULL;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        //  Send reply if it&#x27;s not null</span><br><span class="line">        //  And then get next request from broker</span><br><span class="line">        zmsg_t *request = mdwrk_recv (worker, &amp;reply);</span><br><span class="line">        if (!request)</span><br><span class="line">            break;      //  Interrupted, exit</span><br><span class="line"></span><br><span class="line">        //  Ensure message directory exists</span><br><span class="line">        zfile_mkdir (TITANIC_DIR);</span><br><span class="line"></span><br><span class="line">        //  Generate UUID and save message to disk</span><br><span class="line">        char *uuid = s_generate_uuid ();</span><br><span class="line">        char *filename = s_request_filename (uuid);</span><br><span class="line">        FILE *file = fopen (filename, &quot;w&quot;);</span><br><span class="line">        assert (file);</span><br><span class="line">        zmsg_save (request, file);</span><br><span class="line">        fclose (file);</span><br><span class="line">        free (filename);</span><br><span class="line">        zmsg_destroy (&amp;request);</span><br><span class="line"></span><br><span class="line">        //  Send UUID through to message queue</span><br><span class="line">        reply = zmsg_new ();</span><br><span class="line">        zmsg_addstr (reply, uuid);</span><br><span class="line">        zmsg_send (&amp;reply, pipe);</span><br><span class="line"></span><br><span class="line">        //  Now send UUID back to client</span><br><span class="line">        //  Done by the mdwrk_recv() at the top of the loop</span><br><span class="line">        reply = zmsg_new ();</span><br><span class="line">        zmsg_addstr (reply, &quot;200&quot;);</span><br><span class="line">        zmsg_addstr (reply, uuid);</span><br><span class="line">        free (uuid);</span><br><span class="line">    &#125;</span><br><span class="line">    mdwrk_destroy (&amp;worker);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The titanic.reply task checks if there&#x27;s a reply for the specified</span><br><span class="line">//  request (by UUID), and returns a 200 (OK), 300 (Pending), or 400</span><br><span class="line">//  (Unknown) accordingly:</span><br><span class="line"></span><br><span class="line">static void *</span><br><span class="line">titanic_reply (void *context)</span><br><span class="line">&#123;</span><br><span class="line">    mdwrk_t *worker = mdwrk_new (</span><br><span class="line">        &quot;tcp://localhost:5555&quot;, &quot;titanic.reply&quot;, 0);</span><br><span class="line">    zmsg_t *reply = NULL;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmsg_t *request = mdwrk_recv (worker, &amp;reply);</span><br><span class="line">        if (!request)</span><br><span class="line">            break;      //  Interrupted, exit</span><br><span class="line"></span><br><span class="line">        char *uuid = zmsg_popstr (request);</span><br><span class="line">        char *req_filename = s_request_filename (uuid);</span><br><span class="line">        char *rep_filename = s_reply_filename (uuid);</span><br><span class="line">        if (zfile_exists (rep_filename)) &#123;</span><br><span class="line">            FILE *file = fopen (rep_filename, &quot;r&quot;);</span><br><span class="line">            assert (file);</span><br><span class="line">            reply = zmsg_load (NULL, file);</span><br><span class="line">            zmsg_pushstr (reply, &quot;200&quot;);</span><br><span class="line">            fclose (file);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            reply = zmsg_new ();</span><br><span class="line">            if (zfile_exists (req_filename))</span><br><span class="line">                zmsg_pushstr (reply, &quot;300&quot;); //Pending</span><br><span class="line">            else</span><br><span class="line">                zmsg_pushstr (reply, &quot;400&quot;); //Unknown</span><br><span class="line">        &#125;</span><br><span class="line">        zmsg_destroy (&amp;request);</span><br><span class="line">        free (uuid);</span><br><span class="line">        free (req_filename);</span><br><span class="line">        free (rep_filename);</span><br><span class="line">    &#125;</span><br><span class="line">    mdwrk_destroy (&amp;worker);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The titanic.close task removes any waiting replies for the request</span><br><span class="line">//  (specified by UUID). It&#x27;s idempotent, so it is safe to call more than</span><br><span class="line">//  once in a row:</span><br><span class="line"></span><br><span class="line">static void *</span><br><span class="line">titanic_close (void *context)</span><br><span class="line">&#123;</span><br><span class="line">    mdwrk_t *worker = mdwrk_new (</span><br><span class="line">        &quot;tcp://localhost:5555&quot;, &quot;titanic.close&quot;, 0);</span><br><span class="line">    zmsg_t *reply = NULL;</span><br><span class="line"></span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmsg_t *request = mdwrk_recv (worker, &amp;reply);</span><br><span class="line">        if (!request)</span><br><span class="line">            break;      //  Interrupted, exit</span><br><span class="line"></span><br><span class="line">        char *uuid = zmsg_popstr (request);</span><br><span class="line">        char *req_filename = s_request_filename (uuid);</span><br><span class="line">        char *rep_filename = s_reply_filename (uuid);</span><br><span class="line">        zfile_delete (req_filename);</span><br><span class="line">        zfile_delete (rep_filename);</span><br><span class="line">        free (uuid);</span><br><span class="line">        free (req_filename);</span><br><span class="line">        free (rep_filename);</span><br><span class="line"></span><br><span class="line">        zmsg_destroy (&amp;request);</span><br><span class="line">        reply = zmsg_new ();</span><br><span class="line">        zmsg_addstr (reply, &quot;200&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mdwrk_destroy (&amp;worker);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This is the main thread for the Titanic worker. It starts three child</span><br><span class="line">//  threads; for the request, reply, and close services. It then dispatches</span><br><span class="line">//  requests to workers using a simple brute force disk queue. It receives</span><br><span class="line">//  request UUIDs from the titanic.request service, saves these to a disk</span><br><span class="line">//  file, and then throws each request at MDP workers until it gets a</span><br><span class="line">//  response.</span><br><span class="line"></span><br><span class="line">static int s_service_success (char *uuid);</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line"></span><br><span class="line">    void *request_pipe = zthread_fork (ctx, titanic_request, NULL);</span><br><span class="line">    zthread_new (titanic_reply, NULL);</span><br><span class="line">    zthread_new (titanic_close, NULL);</span><br><span class="line"></span><br><span class="line">    //  Main dispatcher loop</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        //  We&#x27;ll dispatch once per second, if there&#x27;s no activity</span><br><span class="line">        zmq_pollitem_t items [] = &#123; &#123; request_pipe, 0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">        int rc = zmq_poll (items, 1, 1000 * ZMQ_POLL_MSEC);</span><br><span class="line">        if (rc == -1)</span><br><span class="line">            break;              //  Interrupted</span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            //  Ensure message directory exists</span><br><span class="line">            zfile_mkdir (TITANIC_DIR);</span><br><span class="line"></span><br><span class="line">            //  Append UUID to queue, prefixed with &#x27;-&#x27; for pending</span><br><span class="line">            zmsg_t *msg = zmsg_recv (request_pipe);</span><br><span class="line">            if (!msg)</span><br><span class="line">                break;          //  Interrupted</span><br><span class="line">            FILE *file = fopen (TITANIC_DIR &quot;/queue&quot;, &quot;a&quot;);</span><br><span class="line">            char *uuid = zmsg_popstr (msg);</span><br><span class="line">            fprintf (file, &quot;-%s\n&quot;, uuid);</span><br><span class="line">            fclose (file);</span><br><span class="line">            free (uuid);</span><br><span class="line">            zmsg_destroy (&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">        //  Brute force dispatcher</span><br><span class="line">        char entry [] = &quot;?…….:…….:…….:…….:&quot;;</span><br><span class="line">        FILE *file = fopen (TITANIC_DIR &quot;/queue&quot;, &quot;r+&quot;);</span><br><span class="line">        while (file &amp;&amp; fread (entry, 33, 1, file) == 1) &#123;</span><br><span class="line">            //  UUID is prefixed with &#x27;-&#x27; if still waiting</span><br><span class="line">            if (entry [0] == &#x27;-&#x27;) &#123;</span><br><span class="line">                if (verbose)</span><br><span class="line">                    printf (&quot;I: processing request %s\n&quot;, entry + 1);</span><br><span class="line">                if (s_service_success (entry + 1)) &#123;</span><br><span class="line">                    //  Mark queue entry as processed</span><br><span class="line">                    fseek (file, -33, SEEK_CUR);</span><br><span class="line">                    fwrite (&quot;+&quot;, 1, 1, file);</span><br><span class="line">                    fseek (file, 32, SEEK_CUR);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //  Skip end of line, LF or CRLF</span><br><span class="line">            if (fgetc (file) == &#x27;\r&#x27;)</span><br><span class="line">                fgetc (file);</span><br><span class="line">            if (zctx_interrupted)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (file)</span><br><span class="line">            fclose (file);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here, we first check if the requested MDP service is defined or not,</span><br><span class="line">//  using a MMI lookup to the Majordomo broker. If the service exists,</span><br><span class="line">//  we send a request and wait for a reply using the conventional MDP</span><br><span class="line">//  client API. This is not meant to be fast, just very simple:</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">s_service_success (char *uuid)</span><br><span class="line">&#123;</span><br><span class="line">    //  Load request message, service will be first frame</span><br><span class="line">    char *filename = s_request_filename (uuid);</span><br><span class="line">    FILE *file = fopen (filename, &quot;r&quot;);</span><br><span class="line">    free (filename);</span><br><span class="line"></span><br><span class="line">    //  If the client already closed request, treat as successful</span><br><span class="line">    if (!file)</span><br><span class="line">        return 1;</span><br><span class="line"></span><br><span class="line">    zmsg_t *request = zmsg_load (NULL, file);</span><br><span class="line">    fclose (file);</span><br><span class="line">    zframe_t *service = zmsg_pop (request);</span><br><span class="line">    char *service_name = zframe_strdup (service);</span><br><span class="line"></span><br><span class="line">    //  Create MDP client session with short timeout</span><br><span class="line">    mdcli_t *client = mdcli_new (&quot;tcp://localhost:5555&quot;, false);</span><br><span class="line">    mdcli_set_timeout (client, 1000);  //  1 sec</span><br><span class="line">    mdcli_set_retries (client, 1);     //  only 1 retry</span><br><span class="line"></span><br><span class="line">    //  Use MMI protocol to check if service is available</span><br><span class="line">    zmsg_t *mmi_request = zmsg_new ();</span><br><span class="line">    zmsg_add (mmi_request, service);</span><br><span class="line">    zmsg_t *mmi_reply = mdcli_send (client, &quot;mmi.service&quot;, &amp;mmi_request);</span><br><span class="line">    int service_ok = (mmi_reply</span><br><span class="line">        &amp;&amp; zframe_streq (zmsg_first (mmi_reply), &quot;200&quot;));</span><br><span class="line">    zmsg_destroy (&amp;mmi_reply);</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    if (service_ok) &#123;</span><br><span class="line">        zmsg_t *reply = mdcli_send (client, service_name, &amp;request);</span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            filename = s_reply_filename (uuid);</span><br><span class="line">            FILE *file = fopen (filename, &quot;w&quot;);</span><br><span class="line">            assert (file);</span><br><span class="line">            zmsg_save (reply, file);</span><br><span class="line">            fclose (file);</span><br><span class="line">            free (filename);</span><br><span class="line">            result = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        zmsg_destroy (&amp;reply);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        zmsg_destroy (&amp;request);</span><br><span class="line"></span><br><span class="line">    mdcli_destroy (&amp;client);</span><br><span class="line">    free (service_name);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  要测试这个程序，需要先启动mdbroker和titanic，然后再启动ticlient。现在反复重启mdworker，你会看到client收到一个回复然后干净地退出。</p>
<p>  关于这段代码的一些说明：</p>
<ul>
<li>注意一些循环以发送信息开始，另一些以接收开始。这是因为Titanic在不同角色里分别扮演着client和worker。</li>
<li>Titanic broker使用MMI服务发现协议只对正在运行着的服务发送请求。因为在我们的小管家broker中实现的MMI很简陋，它并不会总是正常工作。</li>
<li>我们使用一个inproc连接从titanic.request服务发送请求数据到中心调度器。这避免了调度去必须扫描文件，加载所有请求文件并把它们按照日期／时间顺序排列。</li>
</ul>
<p>　　这个例子中重要的东西不是性能(尽管我没测试过，但应该相当糟糕)，而是它怎么实现的可靠传输。试着先启动mdbroker和titanic程序，然后启动ticlient，接着启动mdworker echo 服务。你可以在运行的时候使用-v选项来做冗余的活动跟踪。你可以停止和重启<em>除了client</em>的任何部分，它不会丢失任何东西。</p>
<p>　　如果你想在实际中使用Titanic，你可能会反复问自己”我怎么能把它弄得快点儿？”</p>
<p>　　下面是我会做的，从简单的实现开始：</p>
<ul>
<li>对所有数据使用单一文件，而不是多个。操作系统通常都是对单个大文件的处理要好于很多小文件的处理。</li>
<li>把文件组织成一个环状的存储空间，好让新的请求能持续写入。在一个单独线程中全速写入磁盘能工作的比较快。</li>
<li>在内存中记录编号，在重启的时候从磁盘存储中重新加载编号。这需要额外的磁盘写入来保证标号在磁盘上的安全性。你会希望在每条message之后都做磁盘同步的工作，甚至是为了防止系统故障而在每N毫秒之后就做一次同步。</li>
<li>使用固态硬盘而不是机械硬盘。</li>
<li>提前申请全部文件，或者在一个大块中申请，它能让环状缓存区根据需要伸缩。这避免了磁盘碎片并保证了大多数的读取和写入工作是持续的。</li>
</ul>
<p>　　诸如此类的。我不建议把信息存放在数据库中，甚至是”快速”的key&#x2F;value数据库，除非你非常喜欢一个特定的数据库并且不用担心性能上的问题。相比如在原始的磁盘文件操作，在数据库上操作需要更多的抽象化设计和上千倍的操作时间。</p>
<p>　　如果你想把Titanic设计的<em>更可靠</em>，把请求备份到第二个server中，该server远到不会受到在第一个server的核爆炸的影响，但也需要不能造成太多延迟。</p>
<p>　　如果你想把Titanic设计的<em>更快但少些可靠性</em>，只把请求和回复都放在内存中。这会给你一个面向非连接的服务，但如果Titanic server本身挂掉的话，那些请求就没办法保存了。</p>
<p><strong>高可靠性组合(双子星模型 Binary Star Pattern)</strong></p>
<p><img src="/img/zmq52.png" alt="f52"></p>
<p>　　双子星模型让两个server成为主－从配套的高可靠性组。在任何时间，这两个中的一个(活跃的那个)接收client程序的连接。另一个(不活跃的那个)什么都不做，但这两个server相互监控着对方。如果活跃着的那个掉线了，一段特定的时间之后不活跃的那个就会接手。</p>
<p>　　我们在iMatix为我们的<a target="_blank" rel="noopener" href="http://www.openamq.org/">OpenAMQ server</a>开发了双子星模型。我们设计它是为了：</p>
<ul>
<li>提供一种直接的高可靠性解决方案。</li>
<li>理解和使用都足够简单。</li>
<li>在且仅在故障的时候才使用。</li>
</ul>
<p>　　假设我们的双子星模型正在运行，下面是一些故障中可能出现的情景：</p>
<ul>
<li>运行主server的硬件发生了致命错误(断电，火灾或者某人不小心拔了插头)，然后掉线了。应用程序会发现，然后重连到备用server。</li>
<li>主server所在的网络挂掉了——可能是路由遭雷击了——然后应用程序会重连到备用server上。</li>
<li>主server崩溃或者被管理员关掉了，并且没有自动重启。</li>
</ul>
<p><img src="/img/zmq53.png" alt="f53"></p>
<p>　　从故障中恢复工作的步骤如下：</p>
<ul>
<li>管理员重启主server并且修复让它掉线的原因。</li>
<li>管理员在某个时候关掉备用server，这会对应用造成一些混乱。</li>
<li>当应用程序重连到主server之后，管理员重启备用server。</li>
</ul>
<p>　　恢复(让主server成为活跃的那个)是人工操作。痛苦的经历教会了我们不要奢望自动恢复，原因有以下几个：</p>
<ul>
<li>故障转移会造成应用的服务中断，大约持续10-30秒。如果有个真正紧急的任务，这要远远好过服务完全挂掉。但如果回复需要花费另外的10-30秒，这最好发生在谷期，这时候用户都没在线。</li>
<li>如果有个紧急任务，首要任务当然是试着修复故障。自动恢复会造成不确定性，如果系统管理员没有双向检查，会无法确定哪个server是活跃的。</li>
<li>自动回复会发生在网络故障转移然后回复的时候，这会让管理员无法确定发生了什么。服务会有一段时间的中断，但原因不清楚。</li>
</ul>
<p>　　如上所说，双子星模型会让备用server失效，然后故障转移到主server(已经重新运行了的)上。事实上，这就是我们怎么处理故障恢复的。</p>
<p>　　关闭双子星进程有两种办法：</p>
<ul>
<li>先停掉备用server，然后在之后的某个时间关闭活跃的主server，或者</li>
<li>按任意顺序停掉两个server，但停掉一个之后等些时间再去停另一个。</li>
</ul>
<p>　　先停掉活跃的哪个，然后是备用的server，会让应用程序断线，然后重连，然后又断线，这会让用户感到迷惑。</p>
<p><strong>更细节的要求</strong></p>
<p>　　双子星非常简单，但仍能准确的工作。事实上，现在这个设计是第三个完整的重构。每个先前的设计都过于复杂，想做的事过于多，我们就开始删减功能，直到变成这个容易理解使用也足够健壮的版本。</p>
<p>　　下面是我们对一个高健壮性框架的一些要求：</p>
<ul>
<li>该故障转移是针对灾难性的系统故障来说的，比如硬件挂掉，火灾，事故等。从普通的servcer挂掉恢复过来已经有了很多简单的方法，我们之前已经说过了。</li>
<li>故障转移的时间应该低于60秒，最好是低于10秒</li>
<li>故障转移必须自动运行，同时恢复必须手动进行。我们希望应用程序能自动转移到备份server上去，但我们不希望在管理员解决了问题之前系统自动切换到主server上去。</li>
<li>client的逻辑必须简单，让开发者容易理解。理想的情况是，它们应该隐藏在client　API之后。</li>
<li>在如何避免导致<em>人格分裂症</em>(双子星组中两个server都认为它们是活跃的server)的问题上要有清楚的网络架构设计的说明书。</li>
<li>这两个server的启动顺序应该没有依赖关系。</li>
<li>必须有如何停掉和重启任何一个server而不中断服务的计划(尽管client应用需要被迫重连)。</li>
<li>管理员必须能全天候监控两个server。</li>
<li>必须能把两个server用专用的高速网络连接起来。也就是说，故障转移同步操作必须去使用一个专门的IP路由。</li>
</ul>
<p>　　下面是一些假设：</p>
<ul>
<li>一个单独的备份server就足够了，不需要多级备份。</li>
<li>主从server对负载的处理能力是一样的，我们不需要设计负载均衡机制。</li>
<li>在所有时间段内需要供应一个完备冗余的备份server。</li>
</ul>
<p>　　我们不准备考虑到以下东西：</p>
<ul>
<li>活动的备份server的使用或者负载均衡机制。在双子星组中，备份server是不活跃的，在主server失效之前不会做任何事。</li>
<li>任何方式的持久化信息或事务的处理。我们假设server或双子星组所在的网络是不可靠的(也可能是不可信任的)。</li>
<li>任何形式的网络自动探测。双子星组是人工操作的并且在网络中明确定义的，是被应用程序知道的东西(至少是在它们的配置数据中)。</li>
<li>在server之间的状态或信息的复制。所有服务器端的状态在服务器挂掉的时候都必须由客户端重新创建。</li>
</ul>
<p>　　下面是我们在双子星模型中使用的术语：</p>
<ul>
<li><em>主要的 Primary</em>:　通常或者启动时是活跃的那个server。</li>
<li><em>备份的　Backup</em>：　通常是不活跃的那个server。它只在主server从网络中消失和client应用要求连接备份server的时候才变成活跃的。</li>
<li><em>活跃的　Active</em>：　接收client连接的server，至少会有一个活跃的server。</li>
<li><em>不活跃的　Passive</em>：　如果活跃的server掉线不活跃的会接管过来。注意在一个双子星组正常运行的时候，主server是活跃的，备份server是不活跃的。当故障转移发生的时候，它们的角色就换一下。</li>
</ul>
<p>　　要配置一个双子星组，你需要：</p>
<ul>
<li>告诉主srever备份的server的位置。</li>
<li>告诉备份server主server的位置。</li>
<li>可选，调整故障转移响应时间一致，这对两个server来说必须是相同的。</li>
</ul>
<p>　　协调的主要部分是你想让serve多久检查一次它们对端的状态，和多快激活故障转移。在我们的例子中，故障转移超时时间的默认值是2000毫秒。如果你减少了这个时间，备份server可能会更快的接管失效的主server的工作，但也可能在主server能自己恢复过来的时候接管。例如，你可能把主server包装在了一个shell脚本中，在server挂掉的时候使用脚本重启它。在这个例子中，超时时间应该高于重启主server需要的时间。</p>
<p>　　对client来说要跟双子星组配合工作，它们必须：</p>
<ol>
<li>知道两个server的地址。</li>
<li>试着连接主server，如果失败，再去连接备份server。</li>
<li>检测失败的连接，主要使用心跳。</li>
<li>试着重连主server，然后才是备份server(按顺序)，中间的延迟至少是服务器进行故障转移所需要的时间。</li>
<li>重建它们在server上所需要的所有状态。</li>
<li>如果需要可靠的消息机制，重发故障转移时间内丢失的数据。</li>
</ol>
<p>　　这不是个小工作，我们通常会把这些封装到一个API中，把它从实际应用代码中隔离开。</p>
<p>　　双子星模型主要有以下限制：</p>
<ul>
<li>一个server进程不能是多于１个双子星组的一部分。</li>
<li>一个主server只能有一个单独的备份server，不能多。</li>
<li>不活跃的server没有做什么有用的工作，因此是浪费的。</li>
<li>备份server必须能够处理所有的负载。</li>
<li>故障转移不能在运行时配置。</li>
<li>client必须做同样的任务，这样才能从故障转移中获益。</li>
</ul>
<p><strong>防止人格分裂症</strong></p>
<p>　　<em>人格分裂症</em>发生在一个集群的不同部分在同一时间都认为它们自己是活跃的部分。它会让应用程序停止相互监测。双子星有个算法用于探测和消除分裂，它依赖于一个三方决策机制(一个server只会在它得到客户端连接请求和看不到同组server的时候才会变成活跃的)。</p>
<p>　　但是，仍然可能(错误的)设计一个网络去糊弄该算法。一个典型的场景是，双子星组分布在两栋建筑中，每栋建筑中都有一套client应用并且在两栋之间只有一个单独的网络连接。切断该连接会形成两套client应用，每套有一半的双子星组，并且每个故障转移server都会成为活跃的。</p>
<p>　　要防止分裂的情况，我们使用一个专用的网络来连接双子星组，简单的可以把它们插在一个相同的交换机上，或者复杂点儿就用线缆直接连接两台机器。</p>
<p>　　一套更复杂的网络配置会使用两个独立的集群连接线路，而不是一个。更近一步的，用于集群之间连接的网卡应该跟消息传输通道使用的网卡区别开来，甚至部署在服务器硬件上的不同通道上。目标是把网络上的故障跟集群本身的故障隔离开。网络端口会有相对比较高的故障率。</p>
<p><strong>双子星实现</strong></p>
<p>　　不需要再说更多的东西了，这里有个双子星服务器的概念性实现。主server和备份server跑的是相同的代码，在运行的时候你确定它们的角色：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">//  bstarsrv: Binary Star server in C</span><br><span class="line">//  Binary Star server proof-of-concept implementation. This server does no</span><br><span class="line">//  real work; it just demonstrates the Binary Star failover model.</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line"></span><br><span class="line">//  States we can be in at any point in time</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    STATE_PRIMARY = 1,          //  Primary, waiting for peer to connect</span><br><span class="line">    STATE_BACKUP = 2,           //  Backup, waiting for peer to connect</span><br><span class="line">    STATE_ACTIVE = 3,           //  Active - accepting connections</span><br><span class="line">    STATE_PASSIVE = 4           //  Passive - not accepting connections</span><br><span class="line">&#125; state_t;</span><br><span class="line"></span><br><span class="line">//  Events, which start with the states our peer can be in</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    PEER_PRIMARY = 1,           //  HA peer is pending primary</span><br><span class="line">    PEER_BACKUP = 2,            //  HA peer is pending backup</span><br><span class="line">    PEER_ACTIVE = 3,            //  HA peer is active</span><br><span class="line">    PEER_PASSIVE = 4,           //  HA peer is passive</span><br><span class="line">    CLIENT_REQUEST = 5          //  Client makes request</span><br><span class="line">&#125; event_t;</span><br><span class="line"></span><br><span class="line">//  Our finite state machine</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    state_t state;              //  Current state</span><br><span class="line">    event_t event;              //  Current event</span><br><span class="line">    int64_t peer_expiry;        //  When peer is considered &#x27;dead&#x27;</span><br><span class="line">&#125; bstar_t;</span><br><span class="line"></span><br><span class="line">//  We send state information this often</span><br><span class="line">//  If peer doesn&#x27;t respond in two heartbeats, it is &#x27;dead&#x27;</span><br><span class="line">#define HEARTBEAT 1000          //  In msecs</span><br><span class="line"></span><br><span class="line">//  The heart of the Binary Star design is its finite-state machine (FSM).</span><br><span class="line">//  The FSM runs one event at a time. We apply an event to the current state,</span><br><span class="line">//  which checks if the event is accepted, and if so, sets a new state:</span><br><span class="line"></span><br><span class="line">static bool</span><br><span class="line">s_state_machine (bstar_t *fsm)</span><br><span class="line">&#123;</span><br><span class="line">    bool exception = false;</span><br><span class="line"></span><br><span class="line">    //  These are the PRIMARY and BACKUP states; we&#x27;re waiting to become</span><br><span class="line">    //  ACTIVE or PASSIVE depending on events we get from our peer:</span><br><span class="line">    if (fsm-&gt;state == STATE_PRIMARY) &#123;</span><br><span class="line">        if (fsm-&gt;event == PEER_BACKUP) &#123;</span><br><span class="line">            printf (&quot;I: connected to backup (passive), ready active\n&quot;);</span><br><span class="line">            fsm-&gt;state = STATE_ACTIVE;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (fsm-&gt;event == PEER_ACTIVE) &#123;</span><br><span class="line">            printf (&quot;I: connected to backup (active), ready passive\n&quot;);</span><br><span class="line">            fsm-&gt;state = STATE_PASSIVE;</span><br><span class="line">        &#125;</span><br><span class="line">        //  Accept client connections</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    if (fsm-&gt;state == STATE_BACKUP) &#123;</span><br><span class="line">        if (fsm-&gt;event == PEER_ACTIVE) &#123;</span><br><span class="line">            printf (&quot;I: connected to primary (active), ready passive\n&quot;);</span><br><span class="line">            fsm-&gt;state = STATE_PASSIVE;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        //  Reject client connections when acting as backup</span><br><span class="line">        if (fsm-&gt;event == CLIENT_REQUEST)</span><br><span class="line">            exception = true;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    //  These are the ACTIVE and PASSIVE states:</span><br><span class="line"></span><br><span class="line">    if (fsm-&gt;state == STATE_ACTIVE) &#123;</span><br><span class="line">        if (fsm-&gt;event == PEER_ACTIVE) &#123;</span><br><span class="line">            //  Two actives would mean split-brain</span><br><span class="line">            printf (&quot;E: fatal error - dual actives, aborting\n&quot;);</span><br><span class="line">            exception = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    //  Server is passive</span><br><span class="line">    //  CLIENT_REQUEST events can trigger failover if peer looks dead</span><br><span class="line">    if (fsm-&gt;state == STATE_PASSIVE) &#123;</span><br><span class="line">        if (fsm-&gt;event == PEER_PRIMARY) &#123;</span><br><span class="line">            //  Peer is restarting - become active, peer will go passive</span><br><span class="line">            printf (&quot;I: primary (passive) is restarting, ready active\n&quot;);</span><br><span class="line">            fsm-&gt;state = STATE_ACTIVE;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (fsm-&gt;event == PEER_BACKUP) &#123;</span><br><span class="line">            //  Peer is restarting - become active, peer will go passive</span><br><span class="line">            printf (&quot;I: backup (passive) is restarting, ready active\n&quot;);</span><br><span class="line">            fsm-&gt;state = STATE_ACTIVE;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (fsm-&gt;event == PEER_PASSIVE) &#123;</span><br><span class="line">            //  Two passives would mean cluster would be non-responsive</span><br><span class="line">            printf (&quot;E: fatal error - dual passives, aborting\n&quot;);</span><br><span class="line">            exception = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (fsm-&gt;event == CLIENT_REQUEST) &#123;</span><br><span class="line">            //  Peer becomes active if timeout has passed</span><br><span class="line">            //  It&#x27;s the client request that triggers the failover</span><br><span class="line">            assert (fsm-&gt;peer_expiry &gt; 0);</span><br><span class="line">            if (zclock_time () &gt;= fsm-&gt;peer_expiry) &#123;</span><br><span class="line">                //  If peer is dead, switch to the active state</span><br><span class="line">                printf (&quot;I: failover successful, ready active\n&quot;);</span><br><span class="line">                fsm-&gt;state = STATE_ACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                //  If peer is alive, reject connections</span><br><span class="line">                exception = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This is our main task. First we bind/connect our sockets with our</span><br><span class="line">//  peer and make sure we will get state messages correctly. We use</span><br><span class="line">//  three sockets; one to publish state, one to subscribe to state, and</span><br><span class="line">//  one for client requests/replies:</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    //  Arguments can be either of:</span><br><span class="line">    //      -p  primary server, at tcp://localhost:5001</span><br><span class="line">    //      -b  backup server, at tcp://localhost:5002</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *statepub = zsocket_new (ctx, ZMQ_PUB);</span><br><span class="line">    void *statesub = zsocket_new (ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (statesub, &quot;&quot;);</span><br><span class="line">    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);</span><br><span class="line">    bstar_t fsm = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-p&quot;)) &#123;</span><br><span class="line">        printf (&quot;I: Primary active, waiting for backup (passive)\n&quot;);</span><br><span class="line">        zsocket_bind (frontend, &quot;tcp://*:5001&quot;);</span><br><span class="line">        zsocket_bind (statepub, &quot;tcp://*:5003&quot;);</span><br><span class="line">        zsocket_connect (statesub, &quot;tcp://localhost:5004&quot;);</span><br><span class="line">        fsm.state = STATE_PRIMARY;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-b&quot;)) &#123;</span><br><span class="line">        printf (&quot;I: Backup passive, waiting for primary (active)\n&quot;);</span><br><span class="line">        zsocket_bind (frontend, &quot;tcp://*:5002&quot;);</span><br><span class="line">        zsocket_bind (statepub, &quot;tcp://*:5004&quot;);</span><br><span class="line">        zsocket_connect (statesub, &quot;tcp://localhost:5003&quot;);</span><br><span class="line">        fsm.state = STATE_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf (&quot;Usage: bstarsrv &#123; -p | -b &#125;\n&quot;);</span><br><span class="line">        zctx_destroy (&amp;ctx);</span><br><span class="line">        exit (0);</span><br><span class="line">    &#125;</span><br><span class="line">    //  We now process events on our two input sockets, and process these</span><br><span class="line">    //  events one at a time via our finite-state machine. Our &quot;work&quot; for</span><br><span class="line">    //  a client request is simply to echo it back:</span><br><span class="line"></span><br><span class="line">    //  Set timer for next outgoing state message</span><br><span class="line">    int64_t send_state_at = zclock_time () + HEARTBEAT;</span><br><span class="line">    while (!zctx_interrupted) &#123;</span><br><span class="line">        zmq_pollitem_t items [] = &#123;</span><br><span class="line">            &#123; frontend, 0, ZMQ_POLLIN, 0 &#125;,</span><br><span class="line">            &#123; statesub, 0, ZMQ_POLLIN, 0 &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        int time_left = (int) ((send_state_at - zclock_time ()));</span><br><span class="line">        if (time_left &lt; 0)</span><br><span class="line">            time_left = 0;</span><br><span class="line">        int rc = zmq_poll (items, 2, time_left * ZMQ_POLL_MSEC);</span><br><span class="line">        if (rc == -1)</span><br><span class="line">            break;              //  Context has been shut down</span><br><span class="line"></span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            //  Have a client request</span><br><span class="line">            zmsg_t *msg = zmsg_recv (frontend);</span><br><span class="line">            fsm.event = CLIENT_REQUEST;</span><br><span class="line">            if (s_state_machine (&amp;fsm) == false)</span><br><span class="line">                //  Answer client by echoing request back</span><br><span class="line">                zmsg_send (&amp;msg, frontend);</span><br><span class="line">            else</span><br><span class="line">                zmsg_destroy (&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">        if (items [1].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            //  Have state from our peer, execute as event</span><br><span class="line">            char *message = zstr_recv (statesub);</span><br><span class="line">            fsm.event = atoi (message);</span><br><span class="line">            free (message);</span><br><span class="line">            if (s_state_machine (&amp;fsm))</span><br><span class="line">                break;          //  Error, so exit</span><br><span class="line">            fsm.peer_expiry = zclock_time () + 2 * HEARTBEAT;</span><br><span class="line">        &#125;</span><br><span class="line">        //  If we timed out, send state to peer</span><br><span class="line">        if (zclock_time () &gt;= send_state_at) &#123;</span><br><span class="line">            char message [2];</span><br><span class="line">            sprintf (message, &quot;%d&quot;, fsm.state);</span><br><span class="line">            zstr_send (statepub, message);</span><br><span class="line">            send_state_at = zclock_time () + HEARTBEAT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (zctx_interrupted)</span><br><span class="line">        printf (&quot;W: interrupted\n&quot;);</span><br><span class="line"></span><br><span class="line">    //  Shutdown sockets and context</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　下面是client:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//  bstarcli: Binary Star client in C</span><br><span class="line">//  Binary Star client proof-of-concept implementation. This client does no</span><br><span class="line">//  real work; it just demonstrates the Binary Star failover model.</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line">#define REQUEST_TIMEOUT     1000    //  msecs</span><br><span class="line">#define SETTLE_DELAY        2000    //  Before failing over</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line"></span><br><span class="line">    char *server [] = &#123; &quot;tcp://localhost:5001&quot;, &quot;tcp://localhost:5002&quot; &#125;;</span><br><span class="line">    uint server_nbr = 0;</span><br><span class="line"></span><br><span class="line">    printf (&quot;I: connecting to server at %s…\n&quot;, server [server_nbr]);</span><br><span class="line">    void *client = zsocket_new (ctx, ZMQ_REQ);</span><br><span class="line">    zsocket_connect (client, server [server_nbr]);</span><br><span class="line"></span><br><span class="line">    int sequence = 0;</span><br><span class="line">    while (!zctx_interrupted) &#123;</span><br><span class="line">        //  We send a request, then we work to get a reply</span><br><span class="line">        char request [10];</span><br><span class="line">        sprintf (request, &quot;%d&quot;, ++sequence);</span><br><span class="line">        zstr_send (client, request);</span><br><span class="line"></span><br><span class="line">        int expect_reply = 1;</span><br><span class="line">        while (expect_reply) &#123;</span><br><span class="line">            //  Poll socket for a reply, with timeout</span><br><span class="line">            zmq_pollitem_t items [] = &#123; &#123; client, 0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">            int rc = zmq_poll (items, 1, REQUEST_TIMEOUT * ZMQ_POLL_MSEC);</span><br><span class="line">            if (rc == -1)</span><br><span class="line">                break;          //  Interrupted</span><br><span class="line"></span><br><span class="line">            //  We use a Lazy Pirate strategy in the client. If there&#x27;s no</span><br><span class="line">            //  reply within our timeout, we close the socket and try again.</span><br><span class="line">            //  In Binary Star, it&#x27;s the client vote that decides which</span><br><span class="line">            //  server is primary; the client must therefore try to connect</span><br><span class="line">            //  to each server in turn:</span><br><span class="line"></span><br><span class="line">            if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">                //  We got a reply from the server, must match sequence</span><br><span class="line">                char *reply = zstr_recv (client);</span><br><span class="line">                if (atoi (reply) == sequence) &#123;</span><br><span class="line">                    printf (&quot;I: server replied OK (%s)\n&quot;, reply);</span><br><span class="line">                    expect_reply = 0;</span><br><span class="line">                    sleep (1);  //  One request per second</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    printf (&quot;E: bad reply from server: %s\n&quot;, reply);</span><br><span class="line">                free (reply);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                printf (&quot;W: no response from server, failing over\n&quot;);</span><br><span class="line"></span><br><span class="line">                //  Old socket is confused; close it and open a new one</span><br><span class="line">                zsocket_destroy (ctx, client);</span><br><span class="line">                server_nbr = (server_nbr + 1) % 2;</span><br><span class="line">                zclock_sleep (SETTLE_DELAY);</span><br><span class="line">                printf (&quot;I: connecting to server at %s…\n&quot;,</span><br><span class="line">                        server [server_nbr]);</span><br><span class="line">                client = zsocket_new (ctx, ZMQ_REQ);</span><br><span class="line">                zsocket_connect (client, server [server_nbr]);</span><br><span class="line"></span><br><span class="line">                //  Send request again, on new socket</span><br><span class="line">                zstr_send (client, request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　要测试双子星，按任意顺序启动server和client：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bstarsrv -p     # Start primary</span><br><span class="line">bstarsrv -b     # Start backup</span><br><span class="line">bstarcli</span><br></pre></td></tr></table></figure>
<p>　　你可以通过关掉主server，然后重启主server并关掉备份server来证明故障转移是否实现。注意clietn是怎么确定触发故障转移然后恢复的。</p>
<p>　　双子星是靠一个无限状态机驱动的。事件是对端的状态，因此”对端活跃”意味着其他server已经告诉我们它是活跃的。”client请求”意味着我们收到了一个client请求。”client　投票”意味着我们收到了一个clietn请求<strong>并且</strong>我们的对端在两个心跳时间内不是活跃的。</p>
<p>　　注意server使用PUB-SUB socket进行状态交换。没有其他的socket组合能用在这里。PUSH和DEALER如果在没有对端接收数据的时候会阻塞。PAIR在对端掉线并重新上线的时候不会进行重连。ROUTER需要在发送信息之前就有对端的地址。</p>
<p><img src="/img/zmq54.png" alt="f54"></p>
<p><strong>双子星反应器</strong></p>
<p>　　把双子星包装起来作为一个可复用的反应器类是足够通用的。不管什么时候反应器收到一条message都会去运行我们的代码去处理。这要比把双子星代码嵌入每个我们想适配的服务器要优雅的多。</p>
<p>　　在C中，我们以前看到过CZMQ包装的zloop类。zloop能让你注册一个socket和定时器时间的句柄。在双子星反应器中，我们为投票者和状态改变(活跃的变成不活跃的，或者反过来)提供处理句柄。下面是bstar的API：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line">//  bstar class - Binary Star reactor</span><br><span class="line"></span><br><span class="line">#include &quot;bstar.h&quot;</span><br><span class="line"></span><br><span class="line">//  States we can be in at any point in time</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    STATE_PRIMARY = 1,          //  Primary, waiting for peer to connect</span><br><span class="line">    STATE_BACKUP = 2,           //  Backup, waiting for peer to connect</span><br><span class="line">    STATE_ACTIVE = 3,           //  Active - accepting connections</span><br><span class="line">    STATE_PASSIVE = 4           //  Passive - not accepting connections</span><br><span class="line">&#125; state_t;</span><br><span class="line"></span><br><span class="line">//  Events, which start with the states our peer can be in</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    PEER_PRIMARY = 1,           //  HA peer is pending primary</span><br><span class="line">    PEER_BACKUP = 2,            //  HA peer is pending backup</span><br><span class="line">    PEER_ACTIVE = 3,            //  HA peer is active</span><br><span class="line">    PEER_PASSIVE = 4,           //  HA peer is passive</span><br><span class="line">    CLIENT_REQUEST = 5          //  Client makes request</span><br><span class="line">&#125; event_t;</span><br><span class="line"></span><br><span class="line">//  Structure of our class</span><br><span class="line"></span><br><span class="line">struct _bstar_t &#123;</span><br><span class="line">    zctx_t *ctx;                //  Our private context</span><br><span class="line">    zloop_t *loop;              //  Reactor loop</span><br><span class="line">    void *statepub;             //  State publisher</span><br><span class="line">    void *statesub;             //  State subscriber</span><br><span class="line">    state_t state;              //  Current state</span><br><span class="line">    event_t event;              //  Current event</span><br><span class="line">    int64_t peer_expiry;        //  When peer is considered &#x27;dead&#x27;</span><br><span class="line">    zloop_fn *voter_fn;         //  Voting socket handler</span><br><span class="line">    void *voter_arg;            //  Arguments for voting handler</span><br><span class="line">    zloop_fn *active_fn;        //  Call when become active</span><br><span class="line">    void *active_arg;           //  Arguments for handler</span><br><span class="line">    zloop_fn *passive_fn;         //  Call when become passive</span><br><span class="line">    void *passive_arg;            //  Arguments for handler</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  The finite-state machine is the same as in the proof-of-concept server.</span><br><span class="line">//  To understand this reactor in detail, first read the CZMQ zloop class.</span><br><span class="line"></span><br><span class="line">//  We send state information every this often</span><br><span class="line">//  If peer doesn&#x27;t respond in two heartbeats, it is &#x27;dead&#x27;</span><br><span class="line">#define BSTAR_HEARTBEAT     1000        //  In msecs</span><br><span class="line"></span><br><span class="line">//  Binary Star finite state machine (applies event to state)</span><br><span class="line">//  Returns -1 if there was an exception, 0 if event was valid.</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">s_execute_fsm (bstar_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    int rc = 0;</span><br><span class="line">    //  Primary server is waiting for peer to connect</span><br><span class="line">    //  Accepts CLIENT_REQUEST events in this state</span><br><span class="line">    if (self-&gt;state == STATE_PRIMARY) &#123;</span><br><span class="line">        if (self-&gt;event == PEER_BACKUP) &#123;</span><br><span class="line">            zclock_log (&quot;I: connected to backup (passive), ready as active&quot;);</span><br><span class="line">            self-&gt;state = STATE_ACTIVE;</span><br><span class="line">            if (self-&gt;active_fn)</span><br><span class="line">                (self-&gt;active_fn) (self-&gt;loop, NULL, self-&gt;active_arg);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == PEER_ACTIVE) &#123;</span><br><span class="line">            zclock_log (&quot;I: connected to backup (active), ready as passive&quot;);</span><br><span class="line">            self-&gt;state = STATE_PASSIVE;</span><br><span class="line">            if (self-&gt;passive_fn)</span><br><span class="line">                (self-&gt;passive_fn) (self-&gt;loop, NULL, self-&gt;passive_arg);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == CLIENT_REQUEST) &#123;</span><br><span class="line">            // Allow client requests to turn us into the active if we&#x27;ve</span><br><span class="line">            // waited sufficiently long to believe the backup is not</span><br><span class="line">            // currently acting as active (i.e., after a failover)</span><br><span class="line">            assert (self-&gt;peer_expiry &gt; 0);</span><br><span class="line">            if (zclock_time () &gt;= self-&gt;peer_expiry) &#123;</span><br><span class="line">                zclock_log (&quot;I: request from client, ready as active&quot;);</span><br><span class="line">                self-&gt;state = STATE_ACTIVE;</span><br><span class="line">                if (self-&gt;active_fn)</span><br><span class="line">                    (self-&gt;active_fn) (self-&gt;loop, NULL, self-&gt;active_arg);</span><br><span class="line">            &#125; else</span><br><span class="line">                // Don&#x27;t respond to clients yet - it&#x27;s possible we&#x27;re</span><br><span class="line">                // performing a failback and the backup is currently active</span><br><span class="line">                rc = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    //  Backup server is waiting for peer to connect</span><br><span class="line">    //  Rejects CLIENT_REQUEST events in this state</span><br><span class="line">    if (self-&gt;state == STATE_BACKUP) &#123;</span><br><span class="line">        if (self-&gt;event == PEER_ACTIVE) &#123;</span><br><span class="line">            zclock_log (&quot;I: connected to primary (active), ready as passive&quot;);</span><br><span class="line">            self-&gt;state = STATE_PASSIVE;</span><br><span class="line">            if (self-&gt;passive_fn)</span><br><span class="line">                (self-&gt;passive_fn) (self-&gt;loop, NULL, self-&gt;passive_arg);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == CLIENT_REQUEST)</span><br><span class="line">            rc = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    //  Server is active</span><br><span class="line">    //  Accepts CLIENT_REQUEST events in this state</span><br><span class="line">    //  The only way out of ACTIVE is death</span><br><span class="line">    if (self-&gt;state == STATE_ACTIVE) &#123;</span><br><span class="line">        if (self-&gt;event == PEER_ACTIVE) &#123;</span><br><span class="line">            //  Two actives would mean split-brain</span><br><span class="line">            zclock_log (&quot;E: fatal error - dual actives, aborting&quot;);</span><br><span class="line">            rc = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    //  Server is passive</span><br><span class="line">    //  CLIENT_REQUEST events can trigger failover if peer looks dead</span><br><span class="line">    if (self-&gt;state == STATE_PASSIVE) &#123;</span><br><span class="line">        if (self-&gt;event == PEER_PRIMARY) &#123;</span><br><span class="line">            //  Peer is restarting - become active, peer will go passive</span><br><span class="line">            zclock_log (&quot;I: primary (passive) is restarting, ready as active&quot;);</span><br><span class="line">            self-&gt;state = STATE_ACTIVE;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == PEER_BACKUP) &#123;</span><br><span class="line">            //  Peer is restarting - become active, peer will go passive</span><br><span class="line">            zclock_log (&quot;I: backup (passive) is restarting, ready as active&quot;);</span><br><span class="line">            self-&gt;state = STATE_ACTIVE;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == PEER_PASSIVE) &#123;</span><br><span class="line">            //  Two passives would mean cluster would be non-responsive</span><br><span class="line">            zclock_log (&quot;E: fatal error - dual passives, aborting&quot;);</span><br><span class="line">            rc = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == CLIENT_REQUEST) &#123;</span><br><span class="line">            //  Peer becomes active if timeout has passed</span><br><span class="line">            //  It&#x27;s the client request that triggers the failover</span><br><span class="line">            assert (self-&gt;peer_expiry &gt; 0);</span><br><span class="line">            if (zclock_time () &gt;= self-&gt;peer_expiry) &#123;</span><br><span class="line">                //  If peer is dead, switch to the active state</span><br><span class="line">                zclock_log (&quot;I: failover successful, ready as active&quot;);</span><br><span class="line">                self-&gt;state = STATE_ACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                //  If peer is alive, reject connections</span><br><span class="line">                rc = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //  Call state change handler if necessary</span><br><span class="line">        if (self-&gt;state == STATE_ACTIVE &amp;&amp; self-&gt;active_fn)</span><br><span class="line">            (self-&gt;active_fn) (self-&gt;loop, NULL, self-&gt;active_arg);</span><br><span class="line">    &#125;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_update_peer_expiry (bstar_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    self-&gt;peer_expiry = zclock_time () + 2 * BSTAR_HEARTBEAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Reactor event handlers…</span><br><span class="line"></span><br><span class="line">//  Publish our state to peer</span><br><span class="line">int s_send_state (zloop_t *loop, zmq_pollitem_t *poller, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    bstar_t *self = (bstar_t *) arg;</span><br><span class="line">    zstr_send (self-&gt;statepub, &quot;%d&quot;, self-&gt;state);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Receive state from peer, execute finite state machine</span><br><span class="line">int s_recv_state (zloop_t *loop, zmq_pollitem_t *poller, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    bstar_t *self = (bstar_t *) arg;</span><br><span class="line">    char *state = zstr_recv (poller-&gt;socket);</span><br><span class="line">    if (state) &#123;</span><br><span class="line">        self-&gt;event = atoi (state);</span><br><span class="line">        s_update_peer_expiry (self);</span><br><span class="line">        free (state);</span><br><span class="line">    &#125;</span><br><span class="line">    return s_execute_fsm (self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Application wants to speak to us, see if it&#x27;s possible</span><br><span class="line">int s_voter_ready (zloop_t *loop, zmq_pollitem_t *poller, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    bstar_t *self = (bstar_t *) arg;</span><br><span class="line">    //  If server can accept input now, call appl handler</span><br><span class="line">    self-&gt;event = CLIENT_REQUEST;</span><br><span class="line">    if (s_execute_fsm (self) == 0)</span><br><span class="line">        (self-&gt;voter_fn) (self-&gt;loop, poller, self-&gt;voter_arg);</span><br><span class="line">    else &#123;</span><br><span class="line">        //  Destroy waiting message, no-one to read it</span><br><span class="line">        zmsg_t *msg = zmsg_recv (poller-&gt;socket);</span><br><span class="line">        zmsg_destroy (&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This is the constructor for our bstar class. We have to tell it</span><br><span class="line">//  whether we&#x27;re primary or backup server, as well as our local and</span><br><span class="line">//  remote endpoints to bind and connect to:</span><br><span class="line"></span><br><span class="line">bstar_t *</span><br><span class="line">bstar_new (int primary, char *local, char *remote)</span><br><span class="line">&#123;</span><br><span class="line">    bstar_t</span><br><span class="line">        *self;</span><br><span class="line"></span><br><span class="line">    self = (bstar_t *) zmalloc (sizeof (bstar_t));</span><br><span class="line"></span><br><span class="line">    //  Initialize the Binary Star</span><br><span class="line">    self-&gt;ctx = zctx_new ();</span><br><span class="line">    self-&gt;loop = zloop_new ();</span><br><span class="line">    self-&gt;state = primary? STATE_PRIMARY: STATE_BACKUP;</span><br><span class="line"></span><br><span class="line">    //  Create publisher for state going to peer</span><br><span class="line">    self-&gt;statepub = zsocket_new (self-&gt;ctx, ZMQ_PUB);</span><br><span class="line">    zsocket_bind (self-&gt;statepub, local);</span><br><span class="line"></span><br><span class="line">    //  Create subscriber for state coming from peer</span><br><span class="line">    self-&gt;statesub = zsocket_new (self-&gt;ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (self-&gt;statesub, &quot;&quot;);</span><br><span class="line">    zsocket_connect (self-&gt;statesub, remote);</span><br><span class="line"></span><br><span class="line">    //  Set-up basic reactor events</span><br><span class="line">    zloop_timer (self-&gt;loop, BSTAR_HEARTBEAT, 0, s_send_state, self);</span><br><span class="line">    zmq_pollitem_t poller = &#123; self-&gt;statesub, 0, ZMQ_POLLIN &#125;;</span><br><span class="line">    zloop_poller (self-&gt;loop, &amp;poller, s_recv_state, self);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The destructor shuts down the bstar reactor:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">bstar_destroy (bstar_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        bstar_t *self = *self_p;</span><br><span class="line">        zloop_destroy (&amp;self-&gt;loop);</span><br><span class="line">        zctx_destroy (&amp;self-&gt;ctx);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method returns the underlying zloop reactor, so we can add</span><br><span class="line">//  additional timers and readers:</span><br><span class="line"></span><br><span class="line">zloop_t *</span><br><span class="line">bstar_zloop (bstar_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    return self-&gt;loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method registers a client voter socket. Messages received</span><br><span class="line">//  on this socket provide the CLIENT_REQUEST events for the Binary Star</span><br><span class="line">//  FSM and are passed to the provided application handler. We require</span><br><span class="line">//  exactly one voter per bstar instance:</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">bstar_voter (bstar_t *self, char *endpoint, int type, zloop_fn handler,</span><br><span class="line">             void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    //  Hold actual handler+arg so we can call this later</span><br><span class="line">    void *socket = zsocket_new (self-&gt;ctx, type);</span><br><span class="line">    zsocket_bind (socket, endpoint);</span><br><span class="line">    assert (!self-&gt;voter_fn);</span><br><span class="line">    self-&gt;voter_fn = handler;</span><br><span class="line">    self-&gt;voter_arg = arg;</span><br><span class="line">    zmq_pollitem_t poller = &#123; socket, 0, ZMQ_POLLIN &#125;;</span><br><span class="line">    return zloop_poller (self-&gt;loop, &amp;poller, s_voter_ready, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Register handlers to be called each time there&#x27;s a state change:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">bstar_new_active (bstar_t *self, zloop_fn handler, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    assert (!self-&gt;active_fn);</span><br><span class="line">    self-&gt;active_fn = handler;</span><br><span class="line">    self-&gt;active_arg = arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">bstar_new_passive (bstar_t *self, zloop_fn handler, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    assert (!self-&gt;passive_fn);</span><br><span class="line">    self-&gt;passive_fn = handler;</span><br><span class="line">    self-&gt;passive_arg = arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Enable/disable verbose tracing, for debugging:</span><br><span class="line"></span><br><span class="line">void bstar_set_verbose (bstar_t *self, bool verbose)</span><br><span class="line">&#123;</span><br><span class="line">    zloop_set_verbose (self-&gt;loop, verbose);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Finally, start the configured reactor. It will end if any handler</span><br><span class="line">//  returns -1 to the reactor, or if the process receives SIGINT or SIGTERM:</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">bstar_start (bstar_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self-&gt;voter_fn);</span><br><span class="line">    s_update_peer_expiry (self);</span><br><span class="line">    return zloop_start (self-&gt;loop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　下面是这个类的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line">//  bstar: Binary Star core class in C</span><br><span class="line">//  bstar class - Binary Star reactor</span><br><span class="line"></span><br><span class="line">#include &quot;bstar.h&quot;</span><br><span class="line"></span><br><span class="line">//  States we can be in at any point in time</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    STATE_PRIMARY = 1,          //  Primary, waiting for peer to connect</span><br><span class="line">    STATE_BACKUP = 2,           //  Backup, waiting for peer to connect</span><br><span class="line">    STATE_ACTIVE = 3,           //  Active - accepting connections</span><br><span class="line">    STATE_PASSIVE = 4           //  Passive - not accepting connections</span><br><span class="line">&#125; state_t;</span><br><span class="line"></span><br><span class="line">//  Events, which start with the states our peer can be in</span><br><span class="line">typedef enum &#123;</span><br><span class="line">    PEER_PRIMARY = 1,           //  HA peer is pending primary</span><br><span class="line">    PEER_BACKUP = 2,            //  HA peer is pending backup</span><br><span class="line">    PEER_ACTIVE = 3,            //  HA peer is active</span><br><span class="line">    PEER_PASSIVE = 4,           //  HA peer is passive</span><br><span class="line">    CLIENT_REQUEST = 5          //  Client makes request</span><br><span class="line">&#125; event_t;</span><br><span class="line"></span><br><span class="line">//  Structure of our class</span><br><span class="line"></span><br><span class="line">struct _bstar_t &#123;</span><br><span class="line">    zctx_t *ctx;                //  Our private context</span><br><span class="line">    zloop_t *loop;              //  Reactor loop</span><br><span class="line">    void *statepub;             //  State publisher</span><br><span class="line">    void *statesub;             //  State subscriber</span><br><span class="line">    state_t state;              //  Current state</span><br><span class="line">    event_t event;              //  Current event</span><br><span class="line">    int64_t peer_expiry;        //  When peer is considered &#x27;dead&#x27;</span><br><span class="line">    zloop_fn *voter_fn;         //  Voting socket handler</span><br><span class="line">    void *voter_arg;            //  Arguments for voting handler</span><br><span class="line">    zloop_fn *active_fn;        //  Call when become active</span><br><span class="line">    void *active_arg;           //  Arguments for handler</span><br><span class="line">    zloop_fn *passive_fn;         //  Call when become passive</span><br><span class="line">    void *passive_arg;            //  Arguments for handler</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  The finite-state machine is the same as in the proof-of-concept server.</span><br><span class="line">//  To understand this reactor in detail, first read the CZMQ zloop class.</span><br><span class="line"></span><br><span class="line">//  We send state information every this often</span><br><span class="line">//  If peer doesn&#x27;t respond in two heartbeats, it is &#x27;dead&#x27;</span><br><span class="line">#define BSTAR_HEARTBEAT     1000        //  In msecs</span><br><span class="line"></span><br><span class="line">//  Binary Star finite state machine (applies event to state)</span><br><span class="line">//  Returns -1 if there was an exception, 0 if event was valid.</span><br><span class="line"></span><br><span class="line">static int</span><br><span class="line">s_execute_fsm (bstar_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    int rc = 0;</span><br><span class="line">    //  Primary server is waiting for peer to connect</span><br><span class="line">    //  Accepts CLIENT_REQUEST events in this state</span><br><span class="line">    if (self-&gt;state == STATE_PRIMARY) &#123;</span><br><span class="line">        if (self-&gt;event == PEER_BACKUP) &#123;</span><br><span class="line">            zclock_log (&quot;I: connected to backup (passive), ready as active&quot;);</span><br><span class="line">            self-&gt;state = STATE_ACTIVE;</span><br><span class="line">            if (self-&gt;active_fn)</span><br><span class="line">                (self-&gt;active_fn) (self-&gt;loop, NULL, self-&gt;active_arg);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == PEER_ACTIVE) &#123;</span><br><span class="line">            zclock_log (&quot;I: connected to backup (active), ready as passive&quot;);</span><br><span class="line">            self-&gt;state = STATE_PASSIVE;</span><br><span class="line">            if (self-&gt;passive_fn)</span><br><span class="line">                (self-&gt;passive_fn) (self-&gt;loop, NULL, self-&gt;passive_arg);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == CLIENT_REQUEST) &#123;</span><br><span class="line">            // Allow client requests to turn us into the active if we&#x27;ve</span><br><span class="line">            // waited sufficiently long to believe the backup is not</span><br><span class="line">            // currently acting as active (i.e., after a failover)</span><br><span class="line">            assert (self-&gt;peer_expiry &gt; 0);</span><br><span class="line">            if (zclock_time () &gt;= self-&gt;peer_expiry) &#123;</span><br><span class="line">                zclock_log (&quot;I: request from client, ready as active&quot;);</span><br><span class="line">                self-&gt;state = STATE_ACTIVE;</span><br><span class="line">                if (self-&gt;active_fn)</span><br><span class="line">                    (self-&gt;active_fn) (self-&gt;loop, NULL, self-&gt;active_arg);</span><br><span class="line">            &#125; else</span><br><span class="line">                // Don&#x27;t respond to clients yet - it&#x27;s possible we&#x27;re</span><br><span class="line">                // performing a failback and the backup is currently active</span><br><span class="line">                rc = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    //  Backup server is waiting for peer to connect</span><br><span class="line">    //  Rejects CLIENT_REQUEST events in this state</span><br><span class="line">    if (self-&gt;state == STATE_BACKUP) &#123;</span><br><span class="line">        if (self-&gt;event == PEER_ACTIVE) &#123;</span><br><span class="line">            zclock_log (&quot;I: connected to primary (active), ready as passive&quot;);</span><br><span class="line">            self-&gt;state = STATE_PASSIVE;</span><br><span class="line">            if (self-&gt;passive_fn)</span><br><span class="line">                (self-&gt;passive_fn) (self-&gt;loop, NULL, self-&gt;passive_arg);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == CLIENT_REQUEST)</span><br><span class="line">            rc = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    //  Server is active</span><br><span class="line">    //  Accepts CLIENT_REQUEST events in this state</span><br><span class="line">    //  The only way out of ACTIVE is death</span><br><span class="line">    if (self-&gt;state == STATE_ACTIVE) &#123;</span><br><span class="line">        if (self-&gt;event == PEER_ACTIVE) &#123;</span><br><span class="line">            //  Two actives would mean split-brain</span><br><span class="line">            zclock_log (&quot;E: fatal error - dual actives, aborting&quot;);</span><br><span class="line">            rc = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    //  Server is passive</span><br><span class="line">    //  CLIENT_REQUEST events can trigger failover if peer looks dead</span><br><span class="line">    if (self-&gt;state == STATE_PASSIVE) &#123;</span><br><span class="line">        if (self-&gt;event == PEER_PRIMARY) &#123;</span><br><span class="line">            //  Peer is restarting - become active, peer will go passive</span><br><span class="line">            zclock_log (&quot;I: primary (passive) is restarting, ready as active&quot;);</span><br><span class="line">            self-&gt;state = STATE_ACTIVE;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == PEER_BACKUP) &#123;</span><br><span class="line">            //  Peer is restarting - become active, peer will go passive</span><br><span class="line">            zclock_log (&quot;I: backup (passive) is restarting, ready as active&quot;);</span><br><span class="line">            self-&gt;state = STATE_ACTIVE;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == PEER_PASSIVE) &#123;</span><br><span class="line">            //  Two passives would mean cluster would be non-responsive</span><br><span class="line">            zclock_log (&quot;E: fatal error - dual passives, aborting&quot;);</span><br><span class="line">            rc = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        if (self-&gt;event == CLIENT_REQUEST) &#123;</span><br><span class="line">            //  Peer becomes active if timeout has passed</span><br><span class="line">            //  It&#x27;s the client request that triggers the failover</span><br><span class="line">            assert (self-&gt;peer_expiry &gt; 0);</span><br><span class="line">            if (zclock_time () &gt;= self-&gt;peer_expiry) &#123;</span><br><span class="line">                //  If peer is dead, switch to the active state</span><br><span class="line">                zclock_log (&quot;I: failover successful, ready as active&quot;);</span><br><span class="line">                self-&gt;state = STATE_ACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                //  If peer is alive, reject connections</span><br><span class="line">                rc = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        //  Call state change handler if necessary</span><br><span class="line">        if (self-&gt;state == STATE_ACTIVE &amp;&amp; self-&gt;active_fn)</span><br><span class="line">            (self-&gt;active_fn) (self-&gt;loop, NULL, self-&gt;active_arg);</span><br><span class="line">    &#125;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_update_peer_expiry (bstar_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    self-&gt;peer_expiry = zclock_time () + 2 * BSTAR_HEARTBEAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Reactor event handlers…</span><br><span class="line"></span><br><span class="line">//  Publish our state to peer</span><br><span class="line">int s_send_state (zloop_t *loop, zmq_pollitem_t *poller, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    bstar_t *self = (bstar_t *) arg;</span><br><span class="line">    zstr_send (self-&gt;statepub, &quot;%d&quot;, self-&gt;state);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Receive state from peer, execute finite state machine</span><br><span class="line">int s_recv_state (zloop_t *loop, zmq_pollitem_t *poller, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    bstar_t *self = (bstar_t *) arg;</span><br><span class="line">    char *state = zstr_recv (poller-&gt;socket);</span><br><span class="line">    if (state) &#123;</span><br><span class="line">        self-&gt;event = atoi (state);</span><br><span class="line">        s_update_peer_expiry (self);</span><br><span class="line">        free (state);</span><br><span class="line">    &#125;</span><br><span class="line">    return s_execute_fsm (self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Application wants to speak to us, see if it&#x27;s possible</span><br><span class="line">int s_voter_ready (zloop_t *loop, zmq_pollitem_t *poller, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    bstar_t *self = (bstar_t *) arg;</span><br><span class="line">    //  If server can accept input now, call appl handler</span><br><span class="line">    self-&gt;event = CLIENT_REQUEST;</span><br><span class="line">    if (s_execute_fsm (self) == 0)</span><br><span class="line">        (self-&gt;voter_fn) (self-&gt;loop, poller, self-&gt;voter_arg);</span><br><span class="line">    else &#123;</span><br><span class="line">        //  Destroy waiting message, no-one to read it</span><br><span class="line">        zmsg_t *msg = zmsg_recv (poller-&gt;socket);</span><br><span class="line">        zmsg_destroy (&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This is the constructor for our bstar class. We have to tell it</span><br><span class="line">//  whether we&#x27;re primary or backup server, as well as our local and</span><br><span class="line">//  remote endpoints to bind and connect to:</span><br><span class="line"></span><br><span class="line">bstar_t *</span><br><span class="line">bstar_new (int primary, char *local, char *remote)</span><br><span class="line">&#123;</span><br><span class="line">    bstar_t</span><br><span class="line">        *self;</span><br><span class="line"></span><br><span class="line">    self = (bstar_t *) zmalloc (sizeof (bstar_t));</span><br><span class="line"></span><br><span class="line">    //  Initialize the Binary Star</span><br><span class="line">    self-&gt;ctx = zctx_new ();</span><br><span class="line">    self-&gt;loop = zloop_new ();</span><br><span class="line">    self-&gt;state = primary? STATE_PRIMARY: STATE_BACKUP;</span><br><span class="line"></span><br><span class="line">    //  Create publisher for state going to peer</span><br><span class="line">    self-&gt;statepub = zsocket_new (self-&gt;ctx, ZMQ_PUB);</span><br><span class="line">    zsocket_bind (self-&gt;statepub, local);</span><br><span class="line"></span><br><span class="line">    //  Create subscriber for state coming from peer</span><br><span class="line">    self-&gt;statesub = zsocket_new (self-&gt;ctx, ZMQ_SUB);</span><br><span class="line">    zsocket_set_subscribe (self-&gt;statesub, &quot;&quot;);</span><br><span class="line">    zsocket_connect (self-&gt;statesub, remote);</span><br><span class="line"></span><br><span class="line">    //  Set-up basic reactor events</span><br><span class="line">    zloop_timer (self-&gt;loop, BSTAR_HEARTBEAT, 0, s_send_state, self);</span><br><span class="line">    zmq_pollitem_t poller = &#123; self-&gt;statesub, 0, ZMQ_POLLIN &#125;;</span><br><span class="line">    zloop_poller (self-&gt;loop, &amp;poller, s_recv_state, self);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The destructor shuts down the bstar reactor:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">bstar_destroy (bstar_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        bstar_t *self = *self_p;</span><br><span class="line">        zloop_destroy (&amp;self-&gt;loop);</span><br><span class="line">        zctx_destroy (&amp;self-&gt;ctx);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method returns the underlying zloop reactor, so we can add</span><br><span class="line">//  additional timers and readers:</span><br><span class="line"></span><br><span class="line">zloop_t *</span><br><span class="line">bstar_zloop (bstar_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    return self-&gt;loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method registers a client voter socket. Messages received</span><br><span class="line">//  on this socket provide the CLIENT_REQUEST events for the Binary Star</span><br><span class="line">//  FSM and are passed to the provided application handler. We require</span><br><span class="line">//  exactly one voter per bstar instance:</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">bstar_voter (bstar_t *self, char *endpoint, int type, zloop_fn handler,</span><br><span class="line">             void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    //  Hold actual handler+arg so we can call this later</span><br><span class="line">    void *socket = zsocket_new (self-&gt;ctx, type);</span><br><span class="line">    zsocket_bind (socket, endpoint);</span><br><span class="line">    assert (!self-&gt;voter_fn);</span><br><span class="line">    self-&gt;voter_fn = handler;</span><br><span class="line">    self-&gt;voter_arg = arg;</span><br><span class="line">    zmq_pollitem_t poller = &#123; socket, 0, ZMQ_POLLIN &#125;;</span><br><span class="line">    return zloop_poller (self-&gt;loop, &amp;poller, s_voter_ready, self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Register handlers to be called each time there&#x27;s a state change:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">bstar_new_active (bstar_t *self, zloop_fn handler, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    assert (!self-&gt;active_fn);</span><br><span class="line">    self-&gt;active_fn = handler;</span><br><span class="line">    self-&gt;active_arg = arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">bstar_new_passive (bstar_t *self, zloop_fn handler, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    assert (!self-&gt;passive_fn);</span><br><span class="line">    self-&gt;passive_fn = handler;</span><br><span class="line">    self-&gt;passive_arg = arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Enable/disable verbose tracing, for debugging:</span><br><span class="line"></span><br><span class="line">void bstar_set_verbose (bstar_t *self, bool verbose)</span><br><span class="line">&#123;</span><br><span class="line">    zloop_set_verbose (self-&gt;loop, verbose);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Finally, start the configured reactor. It will end if any handler</span><br><span class="line">//  returns -1 to the reactor, or if the process receives SIGINT or SIGTERM:</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">bstar_start (bstar_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self-&gt;voter_fn);</span><br><span class="line">    s_update_peer_expiry (self);</span><br><span class="line">    return zloop_start (self-&gt;loop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这给了我们下面这个简短的主程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// bstarsrv2: Bianry Star server, using core class in C</span><br><span class="line">//  Binary Star server, using bstar reactor</span><br><span class="line"></span><br><span class="line">//  Lets us build this source without creating a library</span><br><span class="line">#include &quot;bstar.c&quot;</span><br><span class="line"></span><br><span class="line">//  Echo service</span><br><span class="line">int s_echo (zloop_t *loop, zmq_pollitem_t *poller, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    zmsg_t *msg = zmsg_recv (poller-&gt;socket);</span><br><span class="line">    zmsg_send (&amp;msg, poller-&gt;socket);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    //  Arguments can be either of:</span><br><span class="line">    //      -p  primary server, at tcp://localhost:5001</span><br><span class="line">    //      -b  backup server, at tcp://localhost:5002</span><br><span class="line">    bstar_t *bstar;</span><br><span class="line">    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-p&quot;)) &#123;</span><br><span class="line">        printf (&quot;I: Primary active, waiting for backup (passive)\n&quot;);</span><br><span class="line">        bstar = bstar_new (BSTAR_PRIMARY,</span><br><span class="line">            &quot;tcp://*:5003&quot;, &quot;tcp://localhost:5004&quot;);</span><br><span class="line">        bstar_voter (bstar, &quot;tcp://*:5001&quot;, ZMQ_ROUTER, s_echo, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-b&quot;)) &#123;</span><br><span class="line">        printf (&quot;I: Backup passive, waiting for primary (active)\n&quot;);</span><br><span class="line">        bstar = bstar_new (BSTAR_BACKUP,</span><br><span class="line">            &quot;tcp://*:5004&quot;, &quot;tcp://localhost:5003&quot;);</span><br><span class="line">        bstar_voter (bstar, &quot;tcp://*:5002&quot;, ZMQ_ROUTER, s_echo, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        printf (&quot;Usage: bstarsrvs &#123; -p | -b &#125;\n&quot;);</span><br><span class="line">        exit (0);</span><br><span class="line">    &#125;</span><br><span class="line">    bstar_start (bstar);</span><br><span class="line">    bstar_destroy (&amp;bstar);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>无中介的可靠模型(自由者模型 Freelance Pattern)</strong></p>
<p>　　我们经常解释zmq是”无中介的消息传输框架”，但关注很多以中介为基础的可靠性看起来很讽刺。然而，在消息传输中，就像在现实中一样，中介既是负担也是好东西。在实践中，大多数消息传输框架会从分布式和中间件传输的混合使用中获益。当你能自由根据你想要做的东西权衡利弊后会得到最好的结果。这也就是为什么我可以开两个小时的车去批发商那儿买５箱酒来准备晚会，但也能走１０分钟到街角商店买一瓶在晚饭时候喝。我们对时间、能源和开销的评估对现实世界的经济活动很重要。它们对一个最佳的消息基础框架也非常重要。</p>
<p>　　这也是zmq为什么不<em>强制</em>使用中间件为中心的架构，尽管它给了你构建中介的工具，叫<em>代理proxy</em>，并且我们也构建了很多或者那么多不同的中间件，只是为了练习。</p>
<p>　　因此我们会以解构以中间件为基础的可靠性来结束本章，转向一个我称作自由者模型的分布式的端对端架构。我们的使用场景是一个名字解析服务。这是用zmq框架的一个普遍问题：我们怎么知道该连接的对端呢？把TCP&#x2F;IP地址硬编码到代码中是非常脆弱的。使用配置文件会让管理员做噩梦的。想想一下如果你必须在使用的每台PC或者移动电话上手动配置去让web浏览器知道”google.com”是”74.125.230.82”的情况。</p>
<p>　　一个zmq命名服务(并且我们也会设计一个简单的实现)必须做到下面这些：</p>
<ul>
<li>把一个逻辑名字解析成至少一个绑定的端口和一个连接端口。一个实际的名字服务必须提供可能多个绑定的端口和多个连接端口。</li>
<li>让我们能管理多个并行的环境，比如”test”和”production”，不用去修改代码。</li>
<li>要可靠，因为如果它不能用，那些应用程序就连不上网了。</li>
</ul>
<p>　　从某种观点来看把命名服务放到一个服务为导向的管家中介之后是很聪明的。但，把它暴露出来让client能直接连接会恒简单和更少意外性。如果我们正确的实现了它，命名服务就会是我们必须硬编码或者放到配置文件里的<em>唯一的</em>全局网络端点地址。</p>
<p><img src="/img/zmq55.png" alt="f55"></p>
<p>　　我们要处理的故障类型是server崩溃或重启，server太忙，server过载和网络问题。要得到可靠性，我们会创建一个名字server池，如果有一个挂掉或掉线了，client能连接到另一个。在实际中，两个就会是足够的。但在例子中，我们会假设池子会是任意大小。</p>
<p>　　在这个框架中，一大组client去直接连接一小组server。server会绑定在各自的地址上。它从根本上就跟管家模型那种以中介为基础的实现方式不同，在管家模型那里worker是去连接中介的。clietn有很多选择：</p>
<ul>
<li>使用REQ　socket和懒海盗模型。简单，但需要点额外的工作，不让client重复连接同一个挂掉的server。</li>
<li>使用DEALER socket和分散请求(用负载均衡发送到所有连接着的server去)直到得到一个回复。高效，但不够优雅。</li>
<li>使用ROUTER socket让clietn能指定特定的server。但怎么让client知道server socket的标识呢？可以让server先去ping client（比较复杂），或者让server使用硬编码的client已知的标识(比较恼人的)。</li>
</ul>
<p>　　我们会在接下来的章节分别开发这几个模型。</p>
<p><strong>模型１：简单重试和故障转移</strong></p>
<p> 　　因此我们的菜单貌似会简单、粗暴、复杂或者充满坏味道。让我们从简单的开始，一步步实现这个设想。我们把懒海盗模型重写成能跟多个server通信的东西。</p>
<p> 　　首先启动一个或多个server，在参数中指定一个绑定的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//  flserver1: Freelance server, Model One in C</span><br><span class="line">//  Freelance server - Model 1</span><br><span class="line">//  Trivial echo service</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf (&quot;I: syntax: %s &lt;endpoint&gt;\n&quot;, argv [0]);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *server = zsocket_new (ctx, ZMQ_REP);</span><br><span class="line">    zsocket_bind (server, argv [1]);</span><br><span class="line"></span><br><span class="line">    printf (&quot;I: echo service is ready at %s\n&quot;, argv [1]);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmsg_t *msg = zmsg_recv (server);</span><br><span class="line">        if (!msg)</span><br><span class="line">            break;          //  Interrupted</span><br><span class="line">        zmsg_send (&amp;msg, server);</span><br><span class="line">    &#125;</span><br><span class="line">    if (zctx_interrupted)</span><br><span class="line">        printf (&quot;W: interrupted\n&quot;);</span><br><span class="line"></span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　然后启动client，在参数中指定一个或多个连接地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">//  flclient1: Freelance client, Model One in C</span><br><span class="line">//  Freelance client - Model 1</span><br><span class="line">//  Uses REQ socket to query one or more services</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line">#define REQUEST_TIMEOUT     1000</span><br><span class="line">#define MAX_RETRIES         3       //  Before we abandon</span><br><span class="line"></span><br><span class="line">static zmsg_t *</span><br><span class="line">s_try_request (zctx_t *ctx, char *endpoint, zmsg_t *request)</span><br><span class="line">&#123;</span><br><span class="line">    printf (&quot;I: trying echo service at %s…\n&quot;, endpoint);</span><br><span class="line">    void *client = zsocket_new (ctx, ZMQ_REQ);</span><br><span class="line">    zsocket_connect (client, endpoint);</span><br><span class="line"></span><br><span class="line">    //  Send request, wait safely for reply</span><br><span class="line">    zmsg_t *msg = zmsg_dup (request);</span><br><span class="line">    zmsg_send (&amp;msg, client);</span><br><span class="line">    zmq_pollitem_t items [] = &#123; &#123; client, 0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">    zmq_poll (items, 1, REQUEST_TIMEOUT * ZMQ_POLL_MSEC);</span><br><span class="line">    zmsg_t *reply = NULL;</span><br><span class="line">    if (items [0].revents &amp; ZMQ_POLLIN)</span><br><span class="line">        reply = zmsg_recv (client);</span><br><span class="line"></span><br><span class="line">    //  Close socket in any case, we&#x27;re done with it now</span><br><span class="line">    zsocket_destroy (ctx, client);</span><br><span class="line">    return reply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  The client uses a Lazy Pirate strategy if it only has one server to talk</span><br><span class="line">//  to. If it has two or more servers to talk to, it will try each server just</span><br><span class="line">//  once:</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    zmsg_t *request = zmsg_new ();</span><br><span class="line">    zmsg_addstr (request, &quot;Hello world&quot;);</span><br><span class="line">    zmsg_t *reply = NULL;</span><br><span class="line"></span><br><span class="line">    int endpoints = argc - 1;</span><br><span class="line">    if (endpoints == 0)</span><br><span class="line">        printf (&quot;I: syntax: %s &lt;endpoint&gt; …\n&quot;, argv [0]);</span><br><span class="line">    else</span><br><span class="line">    if (endpoints == 1) &#123;</span><br><span class="line">        //  For one endpoint, we retry N times</span><br><span class="line">        int retries;</span><br><span class="line">        for (retries = 0; retries &lt; MAX_RETRIES; retries++) &#123;</span><br><span class="line">            char *endpoint = argv [1];</span><br><span class="line">            reply = s_try_request (ctx, endpoint, request);</span><br><span class="line">            if (reply)</span><br><span class="line">                break;          //  Successful</span><br><span class="line">            printf (&quot;W: no response from %s, retrying…\n&quot;, endpoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        //  For multiple endpoints, try each at most once</span><br><span class="line">        int endpoint_nbr;</span><br><span class="line">        for (endpoint_nbr = 0; endpoint_nbr &lt; endpoints; endpoint_nbr++) &#123;</span><br><span class="line">            char *endpoint = argv [endpoint_nbr + 1];</span><br><span class="line">            reply = s_try_request (ctx, endpoint, request);</span><br><span class="line">            if (reply)</span><br><span class="line">                break;          //  Successful</span><br><span class="line">            printf (&quot;W: no response from %s\n&quot;, endpoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (reply)</span><br><span class="line">        printf (&quot;Service is running OK\n&quot;);</span><br><span class="line"></span><br><span class="line">    zmsg_destroy (&amp;request);</span><br><span class="line">    zmsg_destroy (&amp;reply);</span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　一个简单的运行例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flserver1 tcp://*:5555 &amp;</span><br><span class="line">flserver1 tcp://*:5556 &amp;</span><br><span class="line">flclient1 tcp://localhost:5555 tcp://localhost:5556</span><br></pre></td></tr></table></figure>
<p>　　尽管是用懒海盗简单实现，但client目标也只是得到一条成功的回复。它有两个技巧，依据你运行的是一个server还是多个server:</p>
<ul>
<li>运行一个server的话，client会重试好几次，跟懒海盗一样。</li>
<li>运行多个server的话，clietn会在每台server上最多重试１次直到它收到回复或者试过所有的server。</li>
</ul>
<p>　　这解决了懒海盗模型中的主要缺点，就是它不能故障转移到备份或替代服务器上去。</p>
<p>　　但是，这样设计在实际应用中并不会工作的很好。如果我们正在连接多个socket并且这时候我们的主命名服务器挂掉的话，就会遭遇难以忍受的超时时间。</p>
<p><strong>模型２：野蛮的霰弹扫射</strong></p>
<p>　　让我们的client换成使用DEALER socket。这里我们的目标是保证在尽可能短的时间内得到一条回复，不管特定的server是启动还是挂掉。我们的client会采用如下实现：</p>
<ul>
<li>把系统运行起来，然后让client连接所有的server。</li>
<li>当我们要发出一个请求，就把它发出去跟服务器个数一样多的次数。</li>
<li>等待第一个回复，并拿到它。</li>
<li>忽略所有其他的回复。</li>
</ul>
<p>　　实际中可能会发生的是当所有的server都在运行的时候，zmq会分发这些请求，因此每个server都会得到一个请求然后发出一个回复。当任何一个server掉线或者断开连接的时候，zmq会把请求分发给余下的server，因此同一个server有可能得到不止一条相同请求。</p>
<p>　　对client来说更恼人的是我们会的到多个回复，但并不会保证能得到确定数量的回复。请求和回复都可能丢失(比如妖士server在处理一个请求的时候挂掉了)。</p>
<p>　　因此我们必须给请求标号并忽略跟请求的标号不匹配的所有回复。在模型１中的server能工作因为它是一个echo服务器。但对理解系统行为来说巧合并不是件好事。因此我们会让模型２中的server消化收到的message并返回一个带有”OK”内容的正确标号的回复。我们会用一个２帧message：一个帧是序列编号，另一个是回复内容。</p>
<p>　　启动一个或多个server，每次都指定一个绑定的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//  flserver2: Freelance server, Model Two in C</span><br><span class="line">//  Freelance server - Model 2</span><br><span class="line">//  Does some work, replies OK, with message sequencing</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        printf (&quot;I: syntax: %s &lt;endpoint&gt;\n&quot;, argv [0]);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line">    void *server = zsocket_new (ctx, ZMQ_REP);</span><br><span class="line">    zsocket_bind (server, argv [1]);</span><br><span class="line"></span><br><span class="line">    printf (&quot;I: service is ready at %s\n&quot;, argv [1]);</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        zmsg_t *request = zmsg_recv (server);</span><br><span class="line">        if (!request)</span><br><span class="line">            break;          //  Interrupted</span><br><span class="line">        //  Fail nastily if run against wrong client</span><br><span class="line">        assert (zmsg_size (request) == 2);</span><br><span class="line"></span><br><span class="line">        zframe_t *identity = zmsg_pop (request);</span><br><span class="line">        zmsg_destroy (&amp;request);</span><br><span class="line"></span><br><span class="line">        zmsg_t *reply = zmsg_new ();</span><br><span class="line">        zmsg_add (reply, identity);</span><br><span class="line">        zmsg_addstr (reply, &quot;OK&quot;);</span><br><span class="line">        zmsg_send (&amp;reply, server);</span><br><span class="line">    &#125;</span><br><span class="line">    if (zctx_interrupted)</span><br><span class="line">        printf (&quot;W: interrupted\n&quot;);</span><br><span class="line"></span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　然后启动client，在参数中指定连接的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">// flclient2: Freelance client, Model Two in C</span><br><span class="line">//  Freelance client - Model 2</span><br><span class="line">//  Uses DEALER socket to blast one or more services</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line"></span><br><span class="line">//  We design our client API as a class, using the CZMQ style</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">typedef struct _flclient_t flclient_t;</span><br><span class="line">flclient_t *flclient_new (void);</span><br><span class="line">void        flclient_destroy (flclient_t **self_p);</span><br><span class="line">void        flclient_connect (flclient_t *self, char *endpoint);</span><br><span class="line">zmsg_t     *flclient_request (flclient_t *self, zmsg_t **request_p);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//  If not a single service replies within this time, give up</span><br><span class="line">#define GLOBAL_TIMEOUT 2500</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc == 1) &#123;</span><br><span class="line">        printf (&quot;I: syntax: %s &lt;endpoint&gt; …\n&quot;, argv [0]);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //  Create new freelance client object</span><br><span class="line">    flclient_t *client = flclient_new ();</span><br><span class="line"></span><br><span class="line">    //  Connect to each endpoint</span><br><span class="line">    int argn;</span><br><span class="line">    for (argn = 1; argn &lt; argc; argn++)</span><br><span class="line">        flclient_connect (client, argv [argn]);</span><br><span class="line"></span><br><span class="line">    //  Send a bunch of name resolution &#x27;requests&#x27;, measure time</span><br><span class="line">    int requests = 10000;</span><br><span class="line">    uint64_t start = zclock_time ();</span><br><span class="line">    while (requests--) &#123;</span><br><span class="line">        zmsg_t *request = zmsg_new ();</span><br><span class="line">        zmsg_addstr (request, &quot;random name&quot;);</span><br><span class="line">        zmsg_t *reply = flclient_request (client, &amp;request);</span><br><span class="line">        if (!reply) &#123;</span><br><span class="line">            printf (&quot;E: name service not available, aborting\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        zmsg_destroy (&amp;reply);</span><br><span class="line">    &#125;</span><br><span class="line">    printf (&quot;Average round trip cost: %d usec\n&quot;,</span><br><span class="line">        (int) (zclock_time () - start) / 10);</span><br><span class="line"></span><br><span class="line">    flclient_destroy (&amp;client);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here is the flclient class implementation. Each instance has a</span><br><span class="line">//  context, a DEALER socket it uses to talk to the servers, a counter</span><br><span class="line">//  of how many servers it&#x27;s connected to, and a request sequence number:</span><br><span class="line"></span><br><span class="line">struct _flclient_t &#123;</span><br><span class="line">    zctx_t *ctx;        //  Our context wrapper</span><br><span class="line">    void *socket;       //  DEALER socket talking to servers</span><br><span class="line">    size_t servers;     //  How many servers we have connected to</span><br><span class="line">    uint sequence;      //  Number of requests ever sent</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  Constructor</span><br><span class="line"></span><br><span class="line">flclient_t *</span><br><span class="line">flclient_new (void)</span><br><span class="line">&#123;</span><br><span class="line">    flclient_t</span><br><span class="line">        *self;</span><br><span class="line"></span><br><span class="line">    self = (flclient_t *) zmalloc (sizeof (flclient_t));</span><br><span class="line">    self-&gt;ctx = zctx_new ();</span><br><span class="line">    self-&gt;socket = zsocket_new (self-&gt;ctx, ZMQ_DEALER);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Destructor</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">flclient_destroy (flclient_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        flclient_t *self = *self_p;</span><br><span class="line">        zctx_destroy (&amp;self-&gt;ctx);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Connect to new server endpoint</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">flclient_connect (flclient_t *self, char *endpoint)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    zsocket_connect (self-&gt;socket, endpoint);</span><br><span class="line">    self-&gt;servers++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method does the hard work. It sends a request to all</span><br><span class="line">//  connected servers in parallel (for this to work, all connections</span><br><span class="line">//  must be successful and completed by this time). It then waits</span><br><span class="line">//  for a single successful reply, and returns that to the caller.</span><br><span class="line">//  Any other replies are just dropped:</span><br><span class="line"></span><br><span class="line">zmsg_t *</span><br><span class="line">flclient_request (flclient_t *self, zmsg_t **request_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    assert (*request_p);</span><br><span class="line">    zmsg_t *request = *request_p;</span><br><span class="line"></span><br><span class="line">    //  Prefix request with sequence number and empty envelope</span><br><span class="line">    char sequence_text [10];</span><br><span class="line">    sprintf (sequence_text, &quot;%u&quot;, ++self-&gt;sequence);</span><br><span class="line">    zmsg_pushstr (request, sequence_text);</span><br><span class="line">    zmsg_pushstr (request, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">    //  Blast the request to all connected servers</span><br><span class="line">    int server;</span><br><span class="line">    for (server = 0; server &lt; self-&gt;servers; server++) &#123;</span><br><span class="line">        zmsg_t *msg = zmsg_dup (request);</span><br><span class="line">        zmsg_send (&amp;msg, self-&gt;socket);</span><br><span class="line">    &#125;</span><br><span class="line">    //  Wait for a matching reply to arrive from anywhere</span><br><span class="line">    //  Since we can poll several times, calculate each one</span><br><span class="line">    zmsg_t *reply = NULL;</span><br><span class="line">    uint64_t endtime = zclock_time () + GLOBAL_TIMEOUT;</span><br><span class="line">    while (zclock_time () &lt; endtime) &#123;</span><br><span class="line">        zmq_pollitem_t items [] = &#123; &#123; self-&gt;socket, 0, ZMQ_POLLIN, 0 &#125; &#125;;</span><br><span class="line">        zmq_poll (items, 1, (endtime - zclock_time ()) * ZMQ_POLL_MSEC);</span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN) &#123;</span><br><span class="line">            //  Reply is [empty][sequence][OK]</span><br><span class="line">            reply = zmsg_recv (self-&gt;socket);</span><br><span class="line">            assert (zmsg_size (reply) == 3);</span><br><span class="line">            free (zmsg_popstr (reply));</span><br><span class="line">            char *sequence = zmsg_popstr (reply);</span><br><span class="line">            int sequence_nbr = atoi (sequence);</span><br><span class="line">            free (sequence);</span><br><span class="line">            if (sequence_nbr == self-&gt;sequence)</span><br><span class="line">                break;</span><br><span class="line">            zmsg_destroy (&amp;reply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zmsg_destroy (request_p);</span><br><span class="line">    return reply;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　关于client的实现有一些说明：</p>
<ul>
<li>client被封装成一个良好的基于类的API，隐藏了创建zmq　context和socket和跟server通信的复杂工作。如果一个霰弹命中才能被成为”通信”。</li>
<li>如果client在几秒中内没有发现<em>任何</em>回复的server，那它就会放弃该请求。</li>
<li>client必须创建一个有效的REP信封，也就是说，在message最前边添加一个空帧。</li>
</ul>
<p>　　该client会运行10,000次名字解析请求(假的，因为我们的server根本什么都没做)然后度量平均开销。在我的测试机上，跟一个server通信的话需要花费60微秒，跟三个server通信，会花费80微秒。</p>
<p>　　我们的霰弹扫射实现的优缺点有：</p>
<ul>
<li>优点：简单，易于实现易于理解。</li>
<li>优点：有故障转移，并且速度相当快，只要有至少一个server在运行。</li>
<li>缺点：有多余的网络流量开销。</li>
<li>缺点：不能先指定好server的顺序，比如说主服务器，次服务器等。</li>
<li>缺点：server每周期最多只能处理一个请求。</li>
</ul>
<p><strong>模型３：　复杂的和充满坏味道的(Model Three: Complex and Nasty)</strong></p>
<p>　　霰弹方式的实现太好以至于不真实。让我们科学点儿来详细讨论下所有的替代设计。我们会探索这些复杂／充满坏味道的选择，即使到最后发现我们更喜欢粗暴点儿的设计。啊哈，这就是我生活的故事。</p>
<p>　　我们可以换成使用一个ROUTER socket来解决client的主要问题。这能让我们把请求发送给指定的server，避免发送给已知挂掉的server，在通常意义上跟我们希望的那样智能。我们也能用同样的方法解决server(单线程)的主要问题。</p>
<p>　　但在两个匿名socket之间连接ROUTER-ROUTER socket是不可能的。两端都只会在收到第一条message的时候(为对端)产生一个标识，因此两端都不能跟另一端通信，因为它们都在等第一条message。解决这个难题的办法就是欺骗，在一个方向上使用硬编码的标识。在一个client&#x2F;server的情景中，正确的欺骗方式是让client”知道”server的标识。在另一个方向上这样做会是不切实际的，非常复杂，因为任意数量的client都可能单独上线。疯狂、复杂、阴险对独裁者来说是必须的品质，但对软件来说就极其糟糕。</p>
<p>　　为了不去创造另外的概念，我们会使用连接地址作为标识。这是个唯一的字符串，双方不需要霰弹模型之外的信息就都知道的东西。用它来连接两个ROUTER socket相当隐秘且有效。</p>
<p>　　回忆下zmq的标识是怎么工作的。server ROUTER socket在绑定之前会设置一个标识。当一个client连接进来的时候，在两端发送一条真实message之前，它们会做一个短暂的握手来交换各自的标识。　client ROUTER socket并不设置标识，会给server发送一个无标识的信息。server会为该client生成一个随机的UUID来自己使用。server发送它的标识(我们同意用的端点地址字符串)给client。</p>
<p>　　这意味着我们的client能把一条message在连接建立之后尽快路由给server(比如说在它自己的ROUTER socket上发出一条用server地址字符串作为标识的message)。并不是在调用<code>zmq_connect()</code>之后就<em>立即</em>工作了，而是在一个随机时间之后。这里有个问题：我们并不知道server什么时候会可用且完成它建立连接的握手。如果server在线，那可能是几毫秒之后，如果server没在线，并且系统管理员出去吃饭了，那现在就可能是１小时了。</p>
<p>　　这里有个小的悖论。我们需要知道server什么时候建立连接能正常工作。在自由者模型中，不像我们先前章节中看到的以broker为基础的模型，server在有client跟它通信之前是静默的。因此我们并不能跟一个server通信，直到它告诉了我们它在线，但这也是我们问起来它的时候它才会告诉的。</p>
<p>　　我的解决办法是稍微混合了一点儿模型２的霰弹方法，也就是说我会向能射中的任何东西开枪(无害的)，如果有东西动了，我们就知道它是活着的。我们不会发射真实的请求，而是一种ping-pong的心跳。</p>
<p>　　这又把我们带到了协议的范围，这里是一个<a target="_blank" rel="noopener" href="http://rfc.zeromq.org/spec:10">简短的自由者模型中client和server怎样交换ping-pong命令和请求－回复命令的定义</a>。</p>
<p>　　对实现一个server它很简短且友好。下面就是我们的echo　server，模型３，现在叫FLP:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//  flserver3: Freelance server, Model Three in C</span><br><span class="line">//  Freelance server - Model 3</span><br><span class="line">//  Uses an ROUTER/ROUTER socket but just one thread</span><br><span class="line"></span><br><span class="line">#include &quot;czmq.h&quot;</span><br><span class="line"></span><br><span class="line">int main (int argc, char *argv [])</span><br><span class="line">&#123;</span><br><span class="line">    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));</span><br><span class="line"></span><br><span class="line">    zctx_t *ctx = zctx_new ();</span><br><span class="line"></span><br><span class="line">    //  Prepare server socket with predictable identity</span><br><span class="line">    char *bind_endpoint = &quot;tcp://*:5555&quot;;</span><br><span class="line">    char *connect_endpoint = &quot;tcp://localhost:5555&quot;;</span><br><span class="line">    void *server = zsocket_new (ctx, ZMQ_ROUTER);</span><br><span class="line">    zmq_setsockopt (server,</span><br><span class="line">        ZMQ_IDENTITY, connect_endpoint, strlen (connect_endpoint));</span><br><span class="line">    zsocket_bind (server, bind_endpoint);</span><br><span class="line">    printf (&quot;I: service is ready at %s\n&quot;, bind_endpoint);</span><br><span class="line"></span><br><span class="line">    while (!zctx_interrupted) &#123;</span><br><span class="line">        zmsg_t *request = zmsg_recv (server);</span><br><span class="line">        if (verbose &amp;&amp; request)</span><br><span class="line">            zmsg_dump (request);</span><br><span class="line">        if (!request)</span><br><span class="line">            break;          //  Interrupted</span><br><span class="line"></span><br><span class="line">        //  Frame 0: identity of client</span><br><span class="line">        //  Frame 1: PING, or client control frame</span><br><span class="line">        //  Frame 2: request body</span><br><span class="line">        zframe_t *identity = zmsg_pop (request);</span><br><span class="line">        zframe_t *control = zmsg_pop (request);</span><br><span class="line">        zmsg_t *reply = zmsg_new ();</span><br><span class="line">        if (zframe_streq (control, &quot;PING&quot;))</span><br><span class="line">            zmsg_addstr (reply, &quot;PONG&quot;);</span><br><span class="line">        else &#123;</span><br><span class="line">            zmsg_add (reply, control);</span><br><span class="line">            zmsg_addstr (reply, &quot;OK&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        zmsg_destroy (&amp;request);</span><br><span class="line">        zmsg_push (reply, identity);</span><br><span class="line">        if (verbose &amp;&amp; reply)</span><br><span class="line">            zmsg_dump (reply);</span><br><span class="line">        zmsg_send (&amp;reply, server);</span><br><span class="line">    &#125;</span><br><span class="line">    if (zctx_interrupted)</span><br><span class="line">        printf (&quot;W: interrupted\n&quot;);</span><br><span class="line"></span><br><span class="line">    zctx_destroy (&amp;ctx);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　然而自由者的client变得非常大。为了清晰，它分成了一个示例应用和一个做这些复杂工作的类。下面是这个顶层的应用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//  flclient3: Freelance client, Model Three in C</span><br><span class="line">//  Freelance client - Model 3</span><br><span class="line">//  Uses flcliapi class to encapsulate Freelance pattern</span><br><span class="line"></span><br><span class="line">//  Lets us build this source without creating a library</span><br><span class="line">#include &quot;flcliapi.c&quot;</span><br><span class="line"></span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">    //  Create new freelance client object</span><br><span class="line">    flcliapi_t *client = flcliapi_new ();</span><br><span class="line"></span><br><span class="line">    //  Connect to several endpoints</span><br><span class="line">    flcliapi_connect (client, &quot;tcp://localhost:5555&quot;);</span><br><span class="line">    flcliapi_connect (client, &quot;tcp://localhost:5556&quot;);</span><br><span class="line">    flcliapi_connect (client, &quot;tcp://localhost:5557&quot;);</span><br><span class="line"></span><br><span class="line">    //  Send a bunch of name resolution &#x27;requests&#x27;, measure time</span><br><span class="line">    int requests = 1000;</span><br><span class="line">    uint64_t start = zclock_time ();</span><br><span class="line">    while (requests--) &#123;</span><br><span class="line">        zmsg_t *request = zmsg_new ();</span><br><span class="line">        zmsg_addstr (request, &quot;random name&quot;);</span><br><span class="line">        zmsg_t *reply = flcliapi_request (client, &amp;request);</span><br><span class="line">        if (!reply) &#123;</span><br><span class="line">            printf (&quot;E: name service not available, aborting\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        zmsg_destroy (&amp;reply);</span><br><span class="line">    &#125;</span><br><span class="line">    printf (&quot;Average round trip cost: %d usec\n&quot;,</span><br><span class="line">        (int) (zclock_time () - start) / 10);</span><br><span class="line"></span><br><span class="line">    flcliapi_destroy (&amp;client);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　下面是跟管家broker差不多一样复杂庞大的client API类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line">//  flcliapi: Freelance client API in C</span><br><span class="line">//  flcliapi class - Freelance Pattern agent class</span><br><span class="line">//  Implements the Freelance Protocol at http://rfc.zeromq.org/spec:10</span><br><span class="line"></span><br><span class="line">#include &quot;flcliapi.h&quot;</span><br><span class="line"></span><br><span class="line">//  If no server replies within this time, abandon request</span><br><span class="line">#define GLOBAL_TIMEOUT  3000    //  msecs</span><br><span class="line">//  PING interval for servers we think are alive</span><br><span class="line">#define PING_INTERVAL   2000    //  msecs</span><br><span class="line">//  Server considered dead if silent for this long</span><br><span class="line">#define SERVER_TTL      6000    //  msecs</span><br><span class="line"></span><br><span class="line">//  This API works in two halves, a common pattern for APIs that need to</span><br><span class="line">//  run in the background. One half is an frontend object our application</span><br><span class="line">//  creates and works with; the other half is a backend &quot;agent&quot; that runs</span><br><span class="line">//  in a background thread. The frontend talks to the backend over an</span><br><span class="line">//  inproc pipe socket:</span><br><span class="line"></span><br><span class="line">//  Structure of our frontend class</span><br><span class="line"></span><br><span class="line">struct _flcliapi_t &#123;</span><br><span class="line">    zctx_t *ctx;        //  Our context wrapper</span><br><span class="line">    void *pipe;         //  Pipe through to flcliapi agent</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//  This is the thread that handles our real flcliapi class</span><br><span class="line">static void flcliapi_agent (void *args, zctx_t *ctx, void *pipe);</span><br><span class="line"></span><br><span class="line">//  Constructor</span><br><span class="line"></span><br><span class="line">flcliapi_t *</span><br><span class="line">flcliapi_new (void)</span><br><span class="line">&#123;</span><br><span class="line">    flcliapi_t</span><br><span class="line">        *self;</span><br><span class="line"></span><br><span class="line">    self = (flcliapi_t *) zmalloc (sizeof (flcliapi_t));</span><br><span class="line">    self-&gt;ctx = zctx_new ();</span><br><span class="line">    self-&gt;pipe = zthread_fork (self-&gt;ctx, flcliapi_agent, NULL);</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Destructor</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">flcliapi_destroy (flcliapi_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        flcliapi_t *self = *self_p;</span><br><span class="line">        zctx_destroy (&amp;self-&gt;ctx);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  To implement the connect method, the frontend object sends a multipart</span><br><span class="line">//  message to the backend agent. The first part is a string &quot;CONNECT&quot;, and</span><br><span class="line">//  the second part is the endpoint. It waits 100msec for the connection to</span><br><span class="line">//  come up, which isn&#x27;t pretty, but saves us from sending all requests to a</span><br><span class="line">//  single server, at startup time:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">flcliapi_connect (flcliapi_t *self, char *endpoint)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    assert (endpoint);</span><br><span class="line">    zmsg_t *msg = zmsg_new ();</span><br><span class="line">    zmsg_addstr (msg, &quot;CONNECT&quot;);</span><br><span class="line">    zmsg_addstr (msg, endpoint);</span><br><span class="line">    zmsg_send (&amp;msg, self-&gt;pipe);</span><br><span class="line">    zclock_sleep (100);      //  Allow connection to come up</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  To implement the request method, the frontend object sends a message</span><br><span class="line">//  to the backend, specifying a command &quot;REQUEST&quot; and the request message:</span><br><span class="line"></span><br><span class="line">zmsg_t *</span><br><span class="line">flcliapi_request (flcliapi_t *self, zmsg_t **request_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self);</span><br><span class="line">    assert (*request_p);</span><br><span class="line"></span><br><span class="line">    zmsg_pushstr (*request_p, &quot;REQUEST&quot;);</span><br><span class="line">    zmsg_send (request_p, self-&gt;pipe);</span><br><span class="line">    zmsg_t *reply = zmsg_recv (self-&gt;pipe);</span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        char *status = zmsg_popstr (reply);</span><br><span class="line">        if (streq (status, &quot;FAILED&quot;))</span><br><span class="line">            zmsg_destroy (&amp;reply);</span><br><span class="line">        free (status);</span><br><span class="line">    &#125;</span><br><span class="line">    return reply;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Here we see the backend agent. It runs as an attached thread, talking</span><br><span class="line">//  to its parent over a pipe socket. It is a fairly complex piece of work</span><br><span class="line">//  so we&#x27;ll break it down into pieces. First, the agent manages a set of</span><br><span class="line">//  servers, using our familiar class approach:</span><br><span class="line"></span><br><span class="line">//  Simple class for one server we talk to</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    char *endpoint;             //  Server identity/endpoint</span><br><span class="line">    uint alive;                 //  1 if known to be alive</span><br><span class="line">    int64_t ping_at;            //  Next ping at this time</span><br><span class="line">    int64_t expires;            //  Expires at this time</span><br><span class="line">&#125; server_t;</span><br><span class="line"></span><br><span class="line">server_t *</span><br><span class="line">server_new (char *endpoint)</span><br><span class="line">&#123;</span><br><span class="line">    server_t *self = (server_t *) zmalloc (sizeof (server_t));</span><br><span class="line">    self-&gt;endpoint = strdup (endpoint);</span><br><span class="line">    self-&gt;alive = 0;</span><br><span class="line">    self-&gt;ping_at = zclock_time () + PING_INTERVAL;</span><br><span class="line">    self-&gt;expires = zclock_time () + SERVER_TTL;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">server_destroy (server_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        server_t *self = *self_p;</span><br><span class="line">        free (self-&gt;endpoint);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">server_ping (const char *key, void *server, void *socket)</span><br><span class="line">&#123;</span><br><span class="line">    server_t *self = (server_t *) server;</span><br><span class="line">    if (zclock_time () &gt;= self-&gt;ping_at) &#123;</span><br><span class="line">        zmsg_t *ping = zmsg_new ();</span><br><span class="line">        zmsg_addstr (ping, self-&gt;endpoint);</span><br><span class="line">        zmsg_addstr (ping, &quot;PING&quot;);</span><br><span class="line">        zmsg_send (&amp;ping, socket);</span><br><span class="line">        self-&gt;ping_at = zclock_time () + PING_INTERVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int</span><br><span class="line">server_tickless (const char *key, void *server, void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    server_t *self = (server_t *) server;</span><br><span class="line">    uint64_t *tickless = (uint64_t *) arg;</span><br><span class="line">    if (*tickless &gt; self-&gt;ping_at)</span><br><span class="line">        *tickless = self-&gt;ping_at;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  We build the agent as a class that&#x27;s capable of processing messages</span><br><span class="line">//  coming in from its various sockets:</span><br><span class="line"></span><br><span class="line">//  Simple class for one background agent</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    zctx_t *ctx;                //  Own context</span><br><span class="line">    void *pipe;                 //  Socket to talk back to application</span><br><span class="line">    void *router;               //  Socket to talk to servers</span><br><span class="line">    zhash_t *servers;           //  Servers we&#x27;ve connected to</span><br><span class="line">    zlist_t *actives;           //  Servers we know are alive</span><br><span class="line">    uint sequence;              //  Number of requests ever sent</span><br><span class="line">    zmsg_t *request;            //  Current request if any</span><br><span class="line">    zmsg_t *reply;              //  Current reply if any</span><br><span class="line">    int64_t expires;            //  Timeout for request/reply</span><br><span class="line">&#125; agent_t;</span><br><span class="line"></span><br><span class="line">agent_t *</span><br><span class="line">agent_new (zctx_t *ctx, void *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    agent_t *self = (agent_t *) zmalloc (sizeof (agent_t));</span><br><span class="line">    self-&gt;ctx = ctx;</span><br><span class="line">    self-&gt;pipe = pipe;</span><br><span class="line">    self-&gt;router = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);</span><br><span class="line">    self-&gt;servers = zhash_new ();</span><br><span class="line">    self-&gt;actives = zlist_new ();</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">agent_destroy (agent_t **self_p)</span><br><span class="line">&#123;</span><br><span class="line">    assert (self_p);</span><br><span class="line">    if (*self_p) &#123;</span><br><span class="line">        agent_t *self = *self_p;</span><br><span class="line">        zhash_destroy (&amp;self-&gt;servers);</span><br><span class="line">        zlist_destroy (&amp;self-&gt;actives);</span><br><span class="line">        zmsg_destroy (&amp;self-&gt;request);</span><br><span class="line">        zmsg_destroy (&amp;self-&gt;reply);</span><br><span class="line">        free (self);</span><br><span class="line">        *self_p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method processes one message from our frontend class</span><br><span class="line">//  (it&#x27;s going to be CONNECT or REQUEST):</span><br><span class="line"></span><br><span class="line">//  Callback when we remove server from agent &#x27;servers&#x27; hash table</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">s_server_free (void *argument)</span><br><span class="line">&#123;</span><br><span class="line">    server_t *server = (server_t *) argument;</span><br><span class="line">    server_destroy (&amp;server);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">agent_control_message (agent_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    zmsg_t *msg = zmsg_recv (self-&gt;pipe);</span><br><span class="line">    char *command = zmsg_popstr (msg);</span><br><span class="line"></span><br><span class="line">    if (streq (command, &quot;CONNECT&quot;)) &#123;</span><br><span class="line">        char *endpoint = zmsg_popstr (msg);</span><br><span class="line">        printf (&quot;I: connecting to %s…\n&quot;, endpoint);</span><br><span class="line">        int rc = zmq_connect (self-&gt;router, endpoint);</span><br><span class="line">        assert (rc == 0);</span><br><span class="line">        server_t *server = server_new (endpoint);</span><br><span class="line">        zhash_insert (self-&gt;servers, endpoint, server);</span><br><span class="line">        zhash_freefn (self-&gt;servers, endpoint, s_server_free);</span><br><span class="line">        zlist_append (self-&gt;actives, server);</span><br><span class="line">        server-&gt;ping_at = zclock_time () + PING_INTERVAL;</span><br><span class="line">        server-&gt;expires = zclock_time () + SERVER_TTL;</span><br><span class="line">        free (endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    if (streq (command, &quot;REQUEST&quot;)) &#123;</span><br><span class="line">        assert (!self-&gt;request);    //  Strict request-reply cycle</span><br><span class="line">        //  Prefix request with sequence number and empty envelope</span><br><span class="line">        char sequence_text [10];</span><br><span class="line">        sprintf (sequence_text, &quot;%u&quot;, ++self-&gt;sequence);</span><br><span class="line">        zmsg_pushstr (msg, sequence_text);</span><br><span class="line">        //  Take ownership of request message</span><br><span class="line">        self-&gt;request = msg;</span><br><span class="line">        msg = NULL;</span><br><span class="line">        //  Request expires after global timeout</span><br><span class="line">        self-&gt;expires = zclock_time () + GLOBAL_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    free (command);</span><br><span class="line">    zmsg_destroy (&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  This method processes one message from a connected</span><br><span class="line">//  server:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">agent_router_message (agent_t *self)</span><br><span class="line">&#123;</span><br><span class="line">    zmsg_t *reply = zmsg_recv (self-&gt;router);</span><br><span class="line"></span><br><span class="line">    //  Frame 0 is server that replied</span><br><span class="line">    char *endpoint = zmsg_popstr (reply);</span><br><span class="line">    server_t *server =</span><br><span class="line">        (server_t *) zhash_lookup (self-&gt;servers, endpoint);</span><br><span class="line">    assert (server);</span><br><span class="line">    free (endpoint);</span><br><span class="line">    if (!server-&gt;alive) &#123;</span><br><span class="line">        zlist_append (self-&gt;actives, server);</span><br><span class="line">        server-&gt;alive = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    server-&gt;ping_at = zclock_time () + PING_INTERVAL;</span><br><span class="line">    server-&gt;expires = zclock_time () + SERVER_TTL;</span><br><span class="line"></span><br><span class="line">    //  Frame 1 may be sequence number for reply</span><br><span class="line">    char *sequence = zmsg_popstr (reply);</span><br><span class="line">    if (atoi (sequence) == self-&gt;sequence) &#123;</span><br><span class="line">        zmsg_pushstr (reply, &quot;OK&quot;);</span><br><span class="line">        zmsg_send (&amp;reply, self-&gt;pipe);</span><br><span class="line">        zmsg_destroy (&amp;self-&gt;request);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        zmsg_destroy (&amp;reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  Finally, here&#x27;s the agent task itself, which polls its two sockets</span><br><span class="line">//  and processes incoming messages:</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">flcliapi_agent (void *args, zctx_t *ctx, void *pipe)</span><br><span class="line">&#123;</span><br><span class="line">    agent_t *self = agent_new (ctx, pipe);</span><br><span class="line"></span><br><span class="line">    zmq_pollitem_t items [] = &#123;</span><br><span class="line">        &#123; self-&gt;pipe, 0, ZMQ_POLLIN, 0 &#125;,</span><br><span class="line">        &#123; self-&gt;router, 0, ZMQ_POLLIN, 0 &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    while (!zctx_interrupted) &#123;</span><br><span class="line">        //  Calculate tickless timer, up to 1 hour</span><br><span class="line">        uint64_t tickless = zclock_time () + 1000 * 3600;</span><br><span class="line">        if (self-&gt;request</span><br><span class="line">        &amp;&amp;  tickless &gt; self-&gt;expires)</span><br><span class="line">            tickless = self-&gt;expires;</span><br><span class="line">        zhash_foreach (self-&gt;servers, server_tickless, &amp;tickless);</span><br><span class="line"></span><br><span class="line">        int rc = zmq_poll (items, 2,</span><br><span class="line">            (tickless - zclock_time ()) * ZMQ_POLL_MSEC);</span><br><span class="line">        if (rc == -1)</span><br><span class="line">            break;              //  Context has been shut down</span><br><span class="line"></span><br><span class="line">        if (items [0].revents &amp; ZMQ_POLLIN)</span><br><span class="line">            agent_control_message (self);</span><br><span class="line"></span><br><span class="line">        if (items [1].revents &amp; ZMQ_POLLIN)</span><br><span class="line">            agent_router_message (self);</span><br><span class="line"></span><br><span class="line">        //  If we&#x27;re processing a request, dispatch to next server</span><br><span class="line">        if (self-&gt;request) &#123;</span><br><span class="line">            if (zclock_time () &gt;= self-&gt;expires) &#123;</span><br><span class="line">                //  Request expired, kill it</span><br><span class="line">                zstr_send (self-&gt;pipe, &quot;FAILED&quot;);</span><br><span class="line">                zmsg_destroy (&amp;self-&gt;request);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                //  Find server to talk to, remove any expired ones</span><br><span class="line">                while (zlist_size (self-&gt;actives)) &#123;</span><br><span class="line">                    server_t *server =</span><br><span class="line">                        (server_t *) zlist_first (self-&gt;actives);</span><br><span class="line">                    if (zclock_time () &gt;= server-&gt;expires) &#123;</span><br><span class="line">                        zlist_pop (self-&gt;actives);</span><br><span class="line">                        server-&gt;alive = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        zmsg_t *request = zmsg_dup (self-&gt;request);</span><br><span class="line">                        zmsg_pushstr (request, server-&gt;endpoint);</span><br><span class="line">                        zmsg_send (&amp;request, self-&gt;router);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //  Disconnect and delete any expired servers</span><br><span class="line">        //  Send heartbeats to idle servers if needed</span><br><span class="line">        zhash_foreach (self-&gt;servers, server_ping, self-&gt;router);</span><br><span class="line">    &#125;</span><br><span class="line">    agent_destroy (&amp;self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　该API的实现相当复杂，使用了两个我们以前没有见过的技巧：</p>
<ul>
<li><strong>多线程API:</strong> 该client　API　包括两部分，一个同步的flciapi类跑在应用线程中，一个异步的<em>agent</em>类跑在后台线程中。回忆下zmq怎么使多线程应用的创建变得容易的。该flcliapi和agent类通过一个inproc socket使用message相互通信。所有的zmq部分(例如创建和销毁context)被隐藏在API中。该agent实际上就像一个小型的broker，在后台跟server通信，好让在我们发起一个请求的时候，它能尽最大努力连接一个它认为在线可用的server。</li>
<li><strong>无计数轮训定时器:</strong>　在以前的轮训循环中我们总是使用一个固定的滴答间隔，比如说１s，这很简单但对电量敏感的client(比如笔记本或者移动电话)就不完美了，在这些设备种滴答会唤醒CPU而浪费电量。为了好玩，也为了帮助拯救地球，agen使用了一个<em>无计数定时器</em>，它会根据我们希望的下次超时时间来计算轮训延迟。一个正确的实现是维持一个排好序的超时时间列表。我们只需要检查一下全部的超时时间然后计算下次的轮训延迟就可以了。</li>
</ul>
<p><strong>结论</strong></p>
<p>　　在本章中，我们看了很多中可靠的请求－回复机制，每种都有相应的缺点和优点。示例代码很大成都上都能拿来实际使用，尽管还没进行优化。在所有的这些不同模型中，有两种能用来放到产品中使用的是管家模型——针对以borker为基础的可靠性和自由者模型——针对无borker的可靠性。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>suntus
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://suntus.github.io/2015/01/30/zmq%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97-4/" title="zmq中文指南_4">https://suntus.github.io/2015/01/30/zmq中文指南-4/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/tr/" rel="tag"># tr</a>
              <a href="/tags/zmq/" rel="tag"># zmq</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2015/01/14/zmq%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97-3/" rel="prev" title="zmq中文指南_3">
      <i class="fa fa-chevron-left"></i> zmq中文指南_3
    </a></div>
      <div class="post-nav-item">
    <a href="/2015/03/02/zmq%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97-5/" rel="next" title="zmq中文指南_5">
      zmq中文指南_5 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%EF%BC%94%E7%AB%A0%EF%BC%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%8D%E5%9B%9E%E5%A4%8D%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">第４章－可靠的请求－回复模型</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">suntus</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">suntus</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
